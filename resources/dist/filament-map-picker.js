var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../../node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet-src.js
var require_leaflet_src = __commonJS({
  "../../../node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
    })(exports, function(exports2) {
      "use strict";
      var version = "1.9.4";
      function extend(dest) {
        var i, j, len, src;
        for (j = 1, len = arguments.length; j < len; j++) {
          src = arguments[j];
          for (i in src) {
            dest[i] = src[i];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ function() {
        function F() {
        }
        return function(proto) {
          F.prototype = proto;
          return new F();
        };
      }();
      function bind(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x, range, includeMax) {
        var max = range[1], min = range[0], d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i in options) {
          obj.options[i] = options[i];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
          params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
          if (array[i] === el) {
            return i;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id) {
        if (id) {
          cancelFn.call(window, id);
        }
      }
      var Util = {
        __proto__: null,
        extend,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
          if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
            NewClass[i] = this[i];
          }
        }
        if (props.statics) {
          extend(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend.apply(null, [proto].concat(props.includes));
        }
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
            proto._initHooks[i2].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          if (includes[i] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i = 0, len = types.length; i < len; i++) {
              if (removeAll) {
                this._off(types[i]);
              } else {
                this._off(types[i], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener = listeners[index2];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                var fn = l.fn;
                if (l.once) {
                  this.off(type, fn, l.ctx);
                }
                fn.call(l.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id in this._eventParents) {
              if (this._eventParents[id].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i].fn === fn && listeners[i].ctx === context) {
              return i;
            }
          }
          return false;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e) {
          for (var id in this._eventParents) {
            this._eventParents[id].fire(e.type, extend({
              layer: e.target,
              propagatedFrom: e.target
            }, e), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
      }
      var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point) {
          return this.clone()._add(toPoint(point));
        },
        _add: function(point) {
          this.x += point.x;
          this.y += point.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point) {
          return this.clone()._subtract(toPoint(point));
        },
        _subtract: function(point) {
          this.x -= point.x;
          this.y -= point.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point) {
          return new Point(this.x * point.x, this.y * point.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point) {
          return new Point(this.x / point.x, this.y / point.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point) {
          point = toPoint(point);
          var x = point.x - this.x, y = point.y - this.y;
          return Math.sqrt(x * x + y * y);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point) {
          point = toPoint(point);
          return point.x === this.x && point.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point) {
          point = toPoint(point);
          return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x, y, round) {
        if (x instanceof Point) {
          return x;
        }
        if (isArray(x)) {
          return new Point(x[0], x[1]);
        }
        if (x === void 0 || x === null) {
          return x;
        }
        if (typeof x === "object" && "x" in x && "y" in x) {
          return new Point(x.x, x.y);
        }
        return new Point(x, y, round);
      }
      function Bounds(a, b) {
        if (!a) {
          return;
        }
        var points = b ? [a, b] : a;
        for (var i = 0, len = points.length; i < len; i++) {
          this.extend(points[i]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min2, max2;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min2 = max2 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min2 = obj.min;
            max2 = obj.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min, max;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min = obj.min;
            max = obj.max;
          } else {
            min = max = obj;
          }
          return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
          return toBounds(
            toPoint(min.x - heightBuffer, min.y - widthBuffer),
            toPoint(max.x + heightBuffer, max.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a, b) {
        if (!a || a instanceof Bounds) {
          return a;
        }
        return new Bounds(a, b);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i = 0, len = latlngs.length; i < len; i++) {
          this.extend(latlngs[i]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng2) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng2(sw2.lat, sw2.lng);
            this._northEast = new LatLng2(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng2(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng2(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng2(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng2(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng2(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng2 || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds) {
          return a;
        }
        return new LatLngBounds(a, b);
      }
      function LatLng2(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng2.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng2(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a, b, c) {
        if (a instanceof LatLng2) {
          return a;
        }
        if (isArray(a) && typeof a[0] !== "object") {
          if (a.length === 3) {
            return new LatLng2(a[0], a[1], a[2]);
          }
          if (a.length === 2) {
            return new LatLng2(a[0], a[1]);
          }
          return null;
        }
        if (a === void 0 || a === null) {
          return a;
        }
        if (typeof a === "object" && "lat" in a) {
          return new LatLng2(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        }
        if (b === void 0) {
          return null;
        }
        return new LatLng2(a, b, c);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point) {
          return this.projection.unproject(point);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
          return new Bounds(min, max);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng2(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng2(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng2(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return this.R * c;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
          return new Point(
            this.R * latlng.lng * d,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point) {
          var d = 180 / Math.PI;
          return new LatLng2(
            (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
            point.x * d / this.R
          );
        },
        bounds: function() {
          var d = earthRadius * Math.PI;
          return new Bounds([-d, -d], [d, d]);
        }()
      };
      function Transformation(a, b, c, d) {
        if (isArray(a)) {
          this._a = a[0];
          this._b = a[1];
          this._c = a[2];
          this._d = a[3];
          return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point, scale2) {
          return this._transform(point.clone(), scale2);
        },
        // destructive transform (faster)
        _transform: function(point, scale2) {
          scale2 = scale2 || 1;
          point.x = scale2 * (this._a * point.x + this._b);
          point.y = scale2 * (this._c * point.y + this._d);
          return point;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point, scale2) {
          scale2 = scale2 || 1;
          return new Point(
            (point.x / scale2 - this._b) / this._a,
            (point.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
      }
      var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];
          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            str += (j ? "L" : "M") + p.x + " " + p.y;
          }
          str += closed ? Browser.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$1 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
      }
      function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) {
          _pointers[e.pointerId] = e;
        }
      }
      function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
      function _onPointerStart(handler, e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(handler, e);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i;
        for (i in event) {
          prop = event[i];
          newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e) {
          if (e.detail !== 1) {
            detail = e.detail;
            return;
          }
          if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e));
            }
          } else {
            detail = 1;
          }
          last = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i = 0, len = classes.length; i < len; i++) {
            el.classList.add(classes[i]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i = 0; i < props.length; i++) {
          if (props[i] in style2) {
            return props[i];
          }
        }
        return false;
      }
      function setTransform(el, offset, scale2) {
        var pos = offset || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point) {
        el._leaflet_pos = point;
        if (Browser.any3d) {
          setTransform(el, point);
        } else {
          el.style.left = point.x + "px";
          el.style.top = point.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale
      };
      function on(obj, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            addOne(obj, types[i], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i = 0, len = types.length; i < len; i++) {
              removeOne(obj, types[i], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id in obj[eventsKey]) {
          var type = id.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id]) {
          return this;
        }
        var handler = function(e) {
          return fn.call(context || obj, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e) {
              e = e || window.event;
              if (isExternalTarget(obj, e)) {
                originalHandler(e);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id] = handler;
      }
      function removeOne(obj, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id];
        if (!handler) {
          return this;
        }
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id] = null;
      }
      function stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else if (e.originalEvent) {
          e.originalEvent._stopped = true;
        } else {
          e.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        return this;
      }
      function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e, container) {
        if (!container) {
          return new Point(e.clientX, e.clientY);
        }
        var scale2 = getScale(container), offset = scale2.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e.clientX - offset.left) / scale2.x - container.clientLeft,
          (e.clientY - offset.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e) {
        return Browser.edge ? e.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
            // Pixels
            e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
              // Lines
              e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                // Pages
                e.deltaX || e.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                      // Legacy Moz lines
                      e.detail ? e.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      });
      var Map = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend({ animate: options.animate }, options.zoom);
              options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset, options) {
          offset = toPoint(offset).round();
          options = options || {};
          if (!offset.x && !offset.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r(i) {
            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
            var log = sq < 1e-9 ? -18 : Math.log(sq);
            return log;
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          var r0 = r(0);
          function w(s) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s));
          }
          function u(s) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
          }
          function easeOut(t) {
            return 1 - Math.pow(1 - t, 1.5);
          }
          var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
          function frame() {
            var t = (Date.now() - start) / duration, s = easeOut(t) * S;
            if (t <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                this.getScaleZoom(w0 / w(s), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
          if (!offset.x && !offset.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset);
          } else {
            if (options.pan) {
              this._rawPanBy(offset);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options) {
          options = this._locateOptions = extend({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng2(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i in pos.coords) {
            if (typeof pos.coords[i] === "number") {
              data[i] = pos.coords[i];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i;
          for (i in this._layers) {
            this._layers[i].remove();
          }
          for (i in this._panes) {
            remove(this._panes[i]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point) {
          var projectedPoint = toPoint(point).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point) {
          return toPoint(point).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point) {
          return toPoint(point).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e) {
          return getMousePosition(e, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function(id) {
          var container = this._container = get(id);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
          addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e) {
          var el = e.target || e.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e, type, canvasTargets) {
          if (e.type === "click") {
            var synth = extend({}, e);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i = 0; i < canvasTargets.length; i++) {
              if (canvasTargets[i].listens(type, true)) {
                filtered.push(canvasTargets[i]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e);
          }
          var target = targets[0];
          var data = {
            originalEvent: e
          };
          if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i = 0; i < targets.length; i++) {
            targets[i].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i = 0, len = this._handlers.length; i < len; i++) {
            this._handlers[i].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset, bounds) {
          if (!bounds) {
            return offset;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
          return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
            return false;
          }
          this.panBy(offset, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c = this.getCenter(), z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function(e) {
          if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id, options) {
        return new Map(id, options);
      }
      var Control2 = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position) {
          var map2 = this._map;
          if (map2) {
            map2.removeControl(this);
          }
          this.options.position = position;
          if (map2) {
            map2.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map2) {
          this.remove();
          this._map = map2;
          var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e) {
          if (this._map && e && e.screenX > 0 && e.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options) {
        return new Control2(options);
      };
      Map.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l + vSide + " " + l + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i in this._controlCorners) {
            remove(this._controlCorners[i]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control2.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
          }
          for (i in overlays) {
            this._addLayer(overlays[i], i, true);
          }
        },
        onAdd: function(map2) {
          this._initLayout();
          this._update();
          this._map = map2;
          map2.on("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map2) {
          Control2.prototype.addTo.call(this, map2);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e) {
              if (e.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e) {
              preventDefault(e);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id) {
          for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i] && stamp(this._layers[i].layer) === id) {
              return this._layers[i];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a, b) {
              return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
          for (i = 0; i < this._layers.length; i++) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e.target));
          var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i = 0; i < removedLayers.length; i++) {
            if (this._map.hasLayer(removedLayers[i])) {
              this._map.removeLayer(removedLayers[i]);
            }
          }
          for (i = 0; i < addedLayers.length; i++) {
            if (!this._map.hasLayer(addedLayers[i])) {
              this._map.addLayer(addedLayers[i]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control2.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map2) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map2 = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map2._zoom === map2.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map2._zoom === map2.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map.mergeOptions({
        zoomControl: true
      });
      Map.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control2.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map2) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map2.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map2 = this._map, y = map2.getSize().y / 2;
          var maxMeters = map2.distance(
            map2.containerPointToLatLng([0, y]),
            map2.containerPointToLatLng([this.options.maxWidth, y])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
          d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
          return pow10 * d;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control2.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map2) {
          map2.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i in map2._layers) {
            if (map2._layers[i].getAttribution) {
              this.addAttribution(map2._layers[i].getAttribution());
            }
          }
          this._update();
          map2.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map2) {
          map2.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i in this._attributions) {
            if (this._attributions[i]) {
              attribs.push(i);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map.mergeOptions({
        attributionControl: true
      });
      Map.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control2.Layers = Layers;
      Control2.Zoom = Zoom;
      Control2.Scale = Scale;
      Control2.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map2) {
          this._map = map2;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map2, name) {
        map2.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e.touches && e.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale(sizedParent);
          var mouseevent = e.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e) {
          if (!this._enabled) {
            return;
          }
          if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset.x && !offset.y) {
            return;
          }
          if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
            return;
          }
          offset.x /= this._parentScale.x;
          offset.y /= this._parentScale.y;
          preventDefault(e);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e.target || e.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset);
          this._moving = true;
          this._lastEvent = e;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e = { originalEvent: this._lastEvent };
          this.fire("predrag", e);
          setPosition(this._element, this._newPos);
          this.fire("drag", e);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round) {
        var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
        for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
          edge2 = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            a = points[i];
            b = points[j];
            if (!(a._code & edge2)) {
              if (b._code & edge2) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
              clippedPoints.push(a);
            } else if (!(b._code & edge2)) {
              p = _getEdgeIntersection(b, a, edge2, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i = 0; i < coords.length; i++) {
          var latlng = toLatLng(coords[i]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
      }
      function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for (i = 0; i < len; i++) {
          if (markers[i]) {
            newPoints.push(points[i]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index2, i, sqDist;
        for (i = first + 1; i <= last - 1; i++) {
          sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index2 = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i = 1, prev = 0, len = points.length; i < len; i++) {
          if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a, b, bounds, useLastCode, round) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a, b];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a, b, code, bounds, round) {
        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
        if (code & 8) {
          x = a.x + dx * (max.y - a.y) / dy;
          y = max.y;
        } else if (code & 4) {
          x = a.x + dx * (min.y - a.y) / dy;
          y = min.y;
        } else if (code & 2) {
          x = max.x;
          y = a.y + dy * (max.x - a.x) / dx;
        } else if (code & 1) {
          x = min.x;
          y = a.y + dy * (min.x - a.x) / dx;
        }
        return new Point(x, y, round);
      }
      function _getBitCode(p, bounds) {
        var code = 0;
        if (p.x < bounds.min.x) {
          code |= 1;
        } else if (p.x > bounds.max.x) {
          code |= 2;
        }
        if (p.y < bounds.min.y) {
          code |= 4;
        } else if (p.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
          t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point(x, y);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i = 0, dist = 0; i < len - 1; i++) {
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
          return new LatLng2(point.y, point.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
          var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
          y = -r * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d * r, y);
        },
        unproject: function(point) {
          var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
            con = e * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng2(phi * d, point.x * d / r);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG4326 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map2) {
          map2.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e) {
          var map2 = e.target;
          if (!map2.hasLayer(this)) {
            return;
          }
          this._map = map2;
          this._zoomAnimated = map2._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map2.on(events, this);
            this.once("remove", function() {
              map2.off(events, this);
            }, this);
          }
          this.onAdd(map2);
          this.fire("add");
          map2.fire("layeradd", { layer: this });
        }
      });
      Map.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id = stamp(layer);
          if (this._layers[id]) {
            return this;
          }
          this._layers[id] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id = stamp(layer);
          if (!this._layers[id]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id = stamp(layer);
          if (this._zoomBoundLayers[id]) {
            delete this._zoomBoundLayers[id];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i, len;
          if (layers2) {
            for (i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id = this.getLayerId(layer);
          this._layers[id] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id]) {
            this._map.removeLayer(this._layers[id]);
          }
          delete this._layers[id];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i, layer;
          for (i in this._layers) {
            layer = this._layers[i];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map2) {
          this.eachLayer(map2.addLayer, map2);
        },
        onRemove: function(map2) {
          this.eachLayer(map2.removeLayer, map2);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id) {
          return this._layers[id];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id in this._layers) {
            var layer = this._layers[id];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup2 = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size) {
            img.style.width = size.x + "px";
            img.style.height = size.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path) {
          var strip = function(str, re, idx) {
            var match = re.exec(str);
            return match && match[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker3) {
          this._marker = marker3;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e) {
          var marker3 = this._marker, map2 = marker3._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker3._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map2.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker3._icon, this._draggable._newPos);
            this._onDrag(e);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDrag: function(e) {
          var marker3 = this._marker, shadow = marker3._shadow, iconPos = getPosition(marker3._icon), latlng = marker3._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker3._latlng = latlng;
          e.latlng = latlng;
          e.oldLatLng = this._oldLatLng;
          marker3.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function(e) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e);
        }
      });
      var Marker = Layer.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map2) {
          this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map2.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map2) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map2.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset) {
          this.options.zIndexOffset = offset;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map2.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker2(latlng, options) {
        return new Marker(latlng, options);
      }
      var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map2) {
          this._renderer = map2.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
          this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
          if (crs.distance === Earth.distance) {
            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map2.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p.subtract(map2.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p.x - map2.project([lat2, lng - lngR]).x;
            this._radiusY = p.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map2.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options, legacyOptions) {
        return new Circle(latlng, options, legacyOptions);
      }
      var Polyline = Path.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
          for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
            var points = this._parts[j];
            for (var i = 1, len = points.length; i < len; i++) {
              p1 = points[i - 1];
              p2 = points[i];
              var sqDist = closest(p, p1, p2, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p, p1, p2);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
              result[i] = toLatLng(latlngs[i]);
              this._bounds.extend(result[i]);
            } else {
              result[i] = this._convertLatLngs(latlngs[i]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w = this._clickTolerance(), p = new Point(w, w);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p),
            this._rawPxBounds.max.add(p)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng2, len = latlngs.length, i, ring;
          if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
              ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
              projectedBounds.extend(ring[i]);
            }
            result.push(ring);
          } else {
            for (i = 0; i < len; i++) {
              this._projectLatlngs(latlngs[i], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i, j, k, len, len2, segment, points;
          for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
            points = this._rings[i];
            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
              segment = clipSegment(points[j], points[j + 1], bounds, j, true);
              if (!segment) {
                continue;
              }
              parts[k] = parts[k] || [];
              parts[k].push(segment[0]);
              if (segment[1] !== points[j + 1] || j === len2 - 2) {
                parts[k].push(segment[1]);
                k++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i = 0, len = parts.length; i < len; i++) {
            parts[i] = simplify(parts[i], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, closed) {
          var i, j, k, len, len2, part, w = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              if (!closed && j === 0) {
                continue;
              }
              if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
      }
      Polyline._flat = _flat;
      var Polygon2 = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng2 && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
          bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
            clipped = clipPolygon(this._rings[i], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var inside = false, part, p1, p2, i, j, k, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              p1 = part[j];
              p2 = part[k];
              if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
      });
      function polygon2(latlngs, options) {
        return new Polygon2(latlngs, options);
      }
      var GeoJSON = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
          if (features) {
            for (i = 0, len = features.length; i < len; i++) {
              feature = features[i];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i = 0, len = coords.length; i < len; i++) {
              latlng = _coordsToLatLng(coords[i]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon2(latlngs, options);
          case "GeometryCollection":
            for (i = 0, len = geometry.geometries.length; i < len; i++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i = 0, len = geometry.features.length; i < len; i++) {
              var featureLayer = geometryToLayer(geometry.features[i], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng2(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i = 0, len = coords.length, latlng; i < len; i++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker.include(PointToGeoJSON);
      Circle.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon2.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e) {
          var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
          setTransform(this._image, offset, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size.x + "px";
          image.style.height = size.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j = 0; j < sourceElements.length; j++) {
              sources.push(sourceElements[j].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i = 0; i < this._url.length; i++) {
            var source = create$1("source");
            source.src = this._url[i];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng2 || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this)) {
            map2.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map2) {
          this._zoomAnimated = map2._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map2._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map2) {
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id in layers2) {
              if (layers2[id]._map) {
                source = layers2[id];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset = offset.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
            map2.removeLayer(map2._popup);
          }
          map2._popup = this;
          return DivOverlay.prototype.openOn.call(this, map2);
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          map2.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size.x) {
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size.y) {
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map2.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options, source) {
        return new Popup(options, source);
      };
      Map.mergeOptions({
        closePopupOnClick: true
      });
      Map.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup2, latlng, options) {
          this._initOverlay(Popup, popup2, latlng, options).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e);
          var target = e.layer || e.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e.latlng);
        },
        _movePopup: function(e) {
          this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function(e) {
          if (e.originalEvent.keyCode === 13) {
            this._openPopup(e);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          this.setOpacity(this.options.opacity);
          map2.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip2 = function(options, source) {
        return new Tooltip(options, source);
      };
      Map.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip3, latlng, options) {
          this._initOverlay(Tooltip, tooltip3, latlng, options).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip3) {
          tooltip3.close();
          return this;
        }
      });
      Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e);
            });
            return;
          }
          this._tooltip._source = e.layer || e.target;
          this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        },
        _moveTooltip: function(e) {
          var latlng = e.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon2(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map2) {
          map2._addZoomLimit(this);
        },
        onRemove: function(map2) {
          this._removeAllTiles();
          remove(this._container);
          map2._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s = this.options.tileSize;
          return s instanceof Point ? s : new Point(s, s);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
            zIndex = layers2[i].style.zIndex;
            if (layers2[i] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z in this._levels) {
            z = Number(z);
            if (this._levels[z].el.children.length || z === zoom2) {
              this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
              this._onUpdateLevel(z);
            } else {
              remove(this._levels[z].el);
              this._removeTilesAtZoom(z);
              this._onRemoveLevel(z);
              delete this._levels[z];
            }
          }
          var level = this._levels[zoom2], map2 = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z in this._levels) {
            remove(this._levels[z].el);
            this._onRemoveLevel(Number(z));
            delete this._levels[z];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x, y, z, minZoom) {
          var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
          coords2.z = +z2;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z2 > minZoom) {
            return this._retainParent(x2, y2, z2, minZoom);
          }
          return false;
        },
        _retainChildren: function(x, y, z, maxZoom) {
          for (var i = 2 * x; i < 2 * x + 2; i++) {
            for (var j = 2 * y; j < 2 * y + 2; j++) {
              var coords = new Point(i, j);
              coords.z = z + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z + 1 < maxZoom) {
                this._retainChildren(i, j, z + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e) {
          var animating = e && (e.pinch || e.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e) {
          this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i in this._levels) {
            this._setZoomTransform(this._levels[i], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var zoom2 = this._clampZoom(map2.getZoom());
          if (center === void 0) {
            center = map2.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
              var coords = new Point(i, j);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < queue.length; i++) {
              this._addTile(queue[i], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
          return [nw, se];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k = key.split(":"), coords = new Point(+k[0], +k[1]);
          coords.z = +k[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer(options);
      }
      var TileLayer = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e, tile);
        },
        _onTileRemove: function(e) {
          e.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i, tile;
          for (i in this._tiles) {
            if (this._tiles[i].coords.z !== this._tileZoom) {
              tile = this._tiles[i].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i].coords;
                remove(tile);
                delete this._tiles[i];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer2(url, options) {
        return new TileLayer(url, options);
      }
      var TileLayerWMS = TileLayer.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend({}, this.defaultWmsParams);
          for (var i in options) {
            if (!(i in this.options)) {
              wmsParams[i] = options[i];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map2) {
          this._crs = this.options.crs || map2.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer.prototype.onAdd.call(this, map2);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer.WMS = TileLayerWMS;
      tileLayer2.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id in this._layers) {
            this._layers[id]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id in this._layers) {
            this._layers[id]._project();
          }
        },
        _updatePaths: function() {
          for (var id in this._layers) {
            this._layers[id]._update();
          }
        },
        _update: function() {
          var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
          this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id in this._layers) {
            layer = this._layers[id];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
          setPosition(container, b.min);
          container.width = m * size.x;
          container.height = m * size.y;
          container.style.width = size.x + "px";
          container.style.height = size.y + "px";
          if (Browser.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b.min.x, -b.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order;
          }
          this._drawLast = order;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order = layer._order;
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
            for (i = 0; i < parts.length; i++) {
              dashValue = Number(parts[i]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
              p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
          if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
          if (s !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e) {
          var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
        },
        _onMouseMove: function(e) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point = this._map.mouseEventToLayerPoint(e);
          this._handleMouseHover(e, point);
        },
        _handleMouseOut: function(e) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e, point) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e, type) {
          this._map._fireDOMEvent(e, type || e.type, layers2);
        },
        _bringToFront: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order.prev = this._drawLast;
          this._drawLast.next = order;
          order.next = null;
          this._drawLast = order;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order.prev = null;
          order.next = this._drawFirst;
          this._drawFirst.prev = order;
          this._drawFirst = order;
          this._requestRedraw(layer);
        }
      });
      function canvas(options) {
        return Browser.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create = Browser.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, size = b.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size)) {
            this._svgSize = size;
            container.setAttribute("width", size.x);
            container.setAttribute("height", size.y);
          }
          setPosition(container, b.min);
          container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path = layer._path = create("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options = layer.options;
          if (!path) {
            return;
          }
          if (options.stroke) {
            path.setAttribute("stroke", options.color);
            path.setAttribute("stroke-opacity", options.opacity);
            path.setAttribute("stroke-width", options.weight);
            path.setAttribute("stroke-linecap", options.lineCap);
            path.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path.setAttribute("fill", options.fillColor || options.color);
            path.setAttribute("fill-opacity", options.fillOpacity);
            path.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
          var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
          this._setPath(layer, d);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser.vml) {
        SVG.include(vmlMixin);
      }
      function svg(options) {
        return Browser.svg || Browser.vml ? new SVG(options) : null;
      }
      Map.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas(options) || svg(options);
        }
      });
      var Rectangle = Polygon2.extend({
        initialize: function(latLngBounds, options) {
          Polygon2.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
          latLngBounds = toLatLngBounds(latLngBounds);
          return [
            latLngBounds.getSouthWest(),
            latLngBounds.getNorthWest(),
            latLngBounds.getNorthEast(),
            latLngBounds.getSouthEast()
          ];
        }
      });
      function rectangle(latLngBounds, options) {
        return new Rectangle(latLngBounds, options);
      }
      SVG.create = create;
      SVG.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map2) {
          this._map = map2;
          this._container = map2._container;
          this._pane = map2._panes.overlayPane;
          this._resetStateTimeout = 0;
          map2.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e) {
          if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e);
          var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size.x + "px";
          this._box.style.height = size.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e) {
          if (e.which !== 1 && e.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e) {
          if (e.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
          var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map2.options.doubleClickZoom === "center") {
            map2.setZoom(zoom2);
          } else {
            map2.setZoomAround(e.containerPoint, zoom2);
          }
        }
      });
      Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map2 = this._map;
            this._draggable = new Draggable(map2._mapPane, map2._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map2.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map2.on("zoomend", this._onZoomEnd, this);
              map2.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map2 = this._map;
          map2._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map2.fire("movestart").fire("dragstart");
          if (map2.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e) {
          if (this._map.options.inertia) {
            var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time);
            this._prunePositions(time);
          }
          this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function(time) {
          while (this._positions.length > 1 && time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset.x < limit.min.x) {
            offset.x = this._viscousLimit(offset.x, limit.min.x);
          }
          if (offset.y < limit.min.y) {
            offset.y = this._viscousLimit(offset.y, limit.min.y);
          }
          if (offset.x > limit.max.x) {
            offset.x = this._viscousLimit(offset.x, limit.max.x);
          }
          if (offset.y > limit.max.y) {
            offset.y = this._viscousLimit(offset.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
          var map2 = this._map, options = map2.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
          map2.fire("dragend", e);
          if (noInertia) {
            map2.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset.x && !offset.y) {
              map2.fire("moveend");
            } else {
              offset = map2._limitOffset(offset, map2.options.maxBounds);
              requestAnimFrame(function() {
                map2.panBy(offset, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map.addInitHook("addHandler", "dragging", Drag);
      Map.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map2) {
          this._map = map2;
          this._setPanDelta(map2.options.keyboardPanDelta);
          this._setZoomDelta(map2.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.left.length; i < len; i++) {
            keys[codes.left[i]] = [-1 * panDelta, 0];
          }
          for (i = 0, len = codes.right.length; i < len; i++) {
            keys[codes.right[i]] = [panDelta, 0];
          }
          for (i = 0, len = codes.down.length; i < len; i++) {
            keys[codes.down[i]] = [0, panDelta];
          }
          for (i = 0, len = codes.up.length; i < len; i++) {
            keys[codes.up[i]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.zoomIn.length; i < len; i++) {
            keys[codes.zoomIn[i]] = zoomDelta;
          }
          for (i = 0, len = codes.zoomOut.length; i < len; i++) {
            keys[codes.zoomOut[i]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          var key = e.keyCode, map2 = this._map, offset;
          if (key in this._panKeys) {
            if (!map2._panAnim || !map2._panAnim._inProgress) {
              offset = this._panKeys[key];
              if (e.shiftKey) {
                offset = toPoint(offset).multiplyBy(3);
              }
              if (map2.options.maxBounds) {
                offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
              }
              if (map2.options.worldCopyJump) {
                var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                map2.panTo(newLatLng);
              } else {
                map2.panBy(offset);
              }
            }
          } else if (key in this._zoomKeys) {
            map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
            map2.closePopup();
          } else {
            return;
          }
          stop(e);
        }
      });
      Map.addInitHook("addHandler", "keyboard", Keyboard);
      Map.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e) {
          var delta = getWheelDelta(e);
          var debounce = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e);
        },
        _performZoom: function() {
          var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
          map2._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map2.options.scrollWheelZoom === "center") {
            map2.setZoom(zoom2 + delta);
          } else {
            map2.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
          clearTimeout(this._holdTimeout);
          if (e.touches.length !== 1) {
            return;
          }
          var first = e.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e) {
          var first = e.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e.target.dispatchEvent(simulatedEvent);
        }
      });
      Map.addInitHook("addHandler", "tapHold", TapHold);
      Map.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
          var map2 = this._map;
          if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
          this._centerPoint = map2.getSize()._divideBy(2);
          this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
          if (map2.options.touchZoom !== "center") {
            this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map2.getZoom();
          this._moved = false;
          this._zooming = true;
          map2._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e);
        },
        _onTouchMove: function(e) {
          if (!e.touches || e.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map2.getScaleZoom(scale2, this._startZoom);
          if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
            this._zoom = map2._limitZoom(this._zoom);
          }
          if (map2.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map2._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map.BoxZoom = BoxZoom;
      Map.DoubleClickZoom = DoubleClickZoom;
      Map.Drag = Drag;
      Map.Keyboard = Keyboard;
      Map.ScrollWheelZoom = ScrollWheelZoom;
      Map.TapHold = TapHold;
      Map.TouchZoom = TouchZoom;
      exports2.Bounds = Bounds;
      exports2.Browser = Browser;
      exports2.CRS = CRS;
      exports2.Canvas = Canvas;
      exports2.Circle = Circle;
      exports2.CircleMarker = CircleMarker;
      exports2.Class = Class;
      exports2.Control = Control2;
      exports2.DivIcon = DivIcon;
      exports2.DivOverlay = DivOverlay;
      exports2.DomEvent = DomEvent;
      exports2.DomUtil = DomUtil;
      exports2.Draggable = Draggable;
      exports2.Evented = Evented;
      exports2.FeatureGroup = FeatureGroup;
      exports2.GeoJSON = GeoJSON;
      exports2.GridLayer = GridLayer;
      exports2.Handler = Handler;
      exports2.Icon = Icon;
      exports2.ImageOverlay = ImageOverlay;
      exports2.LatLng = LatLng2;
      exports2.LatLngBounds = LatLngBounds;
      exports2.Layer = Layer;
      exports2.LayerGroup = LayerGroup;
      exports2.LineUtil = LineUtil;
      exports2.Map = Map;
      exports2.Marker = Marker;
      exports2.Mixin = Mixin;
      exports2.Path = Path;
      exports2.Point = Point;
      exports2.PolyUtil = PolyUtil;
      exports2.Polygon = Polygon2;
      exports2.Polyline = Polyline;
      exports2.Popup = Popup;
      exports2.PosAnimation = PosAnimation;
      exports2.Projection = index;
      exports2.Rectangle = Rectangle;
      exports2.Renderer = Renderer;
      exports2.SVG = SVG;
      exports2.SVGOverlay = SVGOverlay;
      exports2.TileLayer = TileLayer;
      exports2.Tooltip = Tooltip;
      exports2.Transformation = Transformation;
      exports2.Util = Util;
      exports2.VideoOverlay = VideoOverlay;
      exports2.bind = bind;
      exports2.bounds = toBounds;
      exports2.canvas = canvas;
      exports2.circle = circle;
      exports2.circleMarker = circleMarker;
      exports2.control = control;
      exports2.divIcon = divIcon2;
      exports2.extend = extend;
      exports2.featureGroup = featureGroup2;
      exports2.geoJSON = geoJSON;
      exports2.geoJson = geoJson;
      exports2.gridLayer = gridLayer;
      exports2.icon = icon;
      exports2.imageOverlay = imageOverlay;
      exports2.latLng = toLatLng;
      exports2.latLngBounds = toLatLngBounds;
      exports2.layerGroup = layerGroup;
      exports2.map = createMap;
      exports2.marker = marker2;
      exports2.point = toPoint;
      exports2.polygon = polygon2;
      exports2.polyline = polyline;
      exports2.popup = popup;
      exports2.rectangle = rectangle;
      exports2.setOptions = setOptions;
      exports2.stamp = stamp;
      exports2.svg = svg;
      exports2.svgOverlay = svgOverlay;
      exports2.tileLayer = tileLayer2;
      exports2.tooltip = tooltip2;
      exports2.transformation = toTransformation;
      exports2.version = version;
      exports2.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports2.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports2;
    });
  }
});

// resources/js/index.js
var L2 = __toESM(require_leaflet_src(), 1);

// ../../../node_modules/.pnpm/leaflet-fullscreen@1.0.2/node_modules/leaflet-fullscreen/dist/Leaflet.fullscreen.js
L.Control.Fullscreen = L.Control.extend({
  options: {
    position: "topleft",
    title: {
      "false": "View Fullscreen",
      "true": "Exit Fullscreen"
    }
  },
  onAdd: function(map2) {
    var container = L.DomUtil.create("div", "leaflet-control-fullscreen leaflet-bar leaflet-control");
    this.link = L.DomUtil.create("a", "leaflet-control-fullscreen-button leaflet-bar-part", container);
    this.link.href = "#";
    this._map = map2;
    this._map.on("fullscreenchange", this._toggleTitle, this);
    this._toggleTitle();
    L.DomEvent.on(this.link, "click", this._click, this);
    return container;
  },
  _click: function(e) {
    L.DomEvent.stopPropagation(e);
    L.DomEvent.preventDefault(e);
    this._map.toggleFullscreen(this.options);
  },
  _toggleTitle: function() {
    this.link.title = this.options.title[this._map.isFullscreen()];
  }
});
L.Map.include({
  isFullscreen: function() {
    return this._isFullscreen || false;
  },
  toggleFullscreen: function(options) {
    var container = this.getContainer();
    if (this.isFullscreen()) {
      if (options && options.pseudoFullscreen) {
        this._disablePseudoFullscreen(container);
      } else if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else {
        this._disablePseudoFullscreen(container);
      }
    } else {
      if (options && options.pseudoFullscreen) {
        this._enablePseudoFullscreen(container);
      } else if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else {
        this._enablePseudoFullscreen(container);
      }
    }
  },
  _enablePseudoFullscreen: function(container) {
    L.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
    this._setFullscreen(true);
    this.fire("fullscreenchange");
  },
  _disablePseudoFullscreen: function(container) {
    L.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
    this._setFullscreen(false);
    this.fire("fullscreenchange");
  },
  _setFullscreen: function(fullscreen) {
    this._isFullscreen = fullscreen;
    var container = this.getContainer();
    if (fullscreen) {
      L.DomUtil.addClass(container, "leaflet-fullscreen-on");
    } else {
      L.DomUtil.removeClass(container, "leaflet-fullscreen-on");
    }
    this.invalidateSize();
  },
  _onFullscreenChange: function(e) {
    var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    if (fullscreenElement === this.getContainer() && !this._isFullscreen) {
      this._setFullscreen(true);
      this.fire("fullscreenchange");
    } else if (fullscreenElement !== this.getContainer() && this._isFullscreen) {
      this._setFullscreen(false);
      this.fire("fullscreenchange");
    }
  }
});
L.Map.mergeOptions({
  fullscreenControl: false
});
L.Map.addInitHook(function() {
  if (this.options.fullscreenControl) {
    this.fullscreenControl = new L.Control.Fullscreen(this.options.fullscreenControl);
    this.addControl(this.fullscreenControl);
  }
  var fullscreenchange;
  if ("onfullscreenchange" in document) {
    fullscreenchange = "fullscreenchange";
  } else if ("onmozfullscreenchange" in document) {
    fullscreenchange = "mozfullscreenchange";
  } else if ("onwebkitfullscreenchange" in document) {
    fullscreenchange = "webkitfullscreenchange";
  } else if ("onmsfullscreenchange" in document) {
    fullscreenchange = "MSFullscreenChange";
  }
  if (fullscreenchange) {
    var onFullscreenChange = L.bind(this._onFullscreenChange, this);
    this.whenReady(function() {
      L.DomEvent.on(document, fullscreenchange, onFullscreenChange);
    });
    this.on("unload", function() {
      L.DomEvent.off(document, fullscreenchange, onFullscreenChange);
    });
  }
});
L.control.fullscreen = function(options) {
  return new L.Control.Fullscreen(options);
};

// resources/js/index.js
window.mapPicker = ($wire, config) => {
  return {
    map: null,
    tile: null,
    marker: null,
    polygon: [],
    refreshMap() {
      console.log("Refresh Map");
      this.map.flyTo(this.getCoordinates());
      $wire.$refresh();
    },
    createMap: function(el) {
      const that = this;
      $wire.on("refreshMap", this.refreshMap.bind(this));
      this.map = L2.map(el, config.controls);
      this.map.on("load", () => {
        setTimeout(() => this.map.invalidateSize(true), 0);
        if (config.showMarker === true) {
          this.marker.setLatLng(this.map.getCenter());
        }
      });
      if (!config.draggable) {
        this.map.dragging.disable();
      }
      this.tile = L2.tileLayer(config.tilesUrl, {
        attribution: config.attribution,
        minZoom: config.minZoom,
        maxZoom: config.maxZoom,
        tileSize: config.tileSize,
        zoomOffset: config.zoomOffset,
        detectRetina: config.detectRetina
      }).addTo(this.map);
      if (config.showMarker === true) {
        const markerColor = config.markerColor || "#3b82f6";
        const svgIcon = L2.divIcon({
          html: `<svg xmlns="http://www.w3.org/2000/svg" class="map-icon" fill="${markerColor}" width="36" height="36" viewBox="0 0 24 24"><path d="M12 0c-4.198 0-8 3.403-8 7.602 0 4.198 3.469 9.21 8 16.398 4.531-7.188 8-12.2 8-16.398 0-4.199-3.801-7.602-8-7.602zm0 11c-1.657 0-3-1.343-3-3s1.343-3 3-3 3 1.343 3 3-1.343 3-3 3z"/></svg>`,
          className: "",
          iconSize: [36, 36],
          iconAnchor: [18, 36]
        });
        this.marker = L2.marker([0, 0], {
          icon: svgIcon,
          draggable: false,
          autoPan: true
        }).addTo(this.map);
        this.map.on(
          "move",
          () => this.marker.setLatLng(this.map.getCenter())
        );
      }
      this.map.on("moveend", () => {
        let coordinates = this.getCoordinates();
        if (config.draggable && (coordinates.lng !== this.map.getCenter()["lng"] || coordinates.lat !== this.map.getCenter()["lat"])) {
          console.log(config.statePath);
          console.log("moveend");
          $wire.set(
            config.statePath,
            {
              lat: this.map.getCenter().lat,
              lng: this.map.getCenter().lng,
              polygon: $wire.get(config.statePath).polygon ?? this.polygon
            },
            false
          );
          console.log($wire.get(config.statePath));
          if (config.liveLocation) {
            $wire.$refresh();
          }
        }
      });
      this.map.on("locationfound", function() {
        that.map.setZoom(config.controls.zoom);
      });
      let location = this.getCoordinates();
      if (!location.lat && !location.lng) {
        this.map.locate({
          setView: true,
          maxZoom: config.controls.maxZoom,
          enableHighAccuracy: true,
          watch: false
        });
      } else {
        this.map.setView(new L2.LatLng(location.lat, location.lng));
      }
      const createAreaTooltip = (layer) => {
        if (layer.areaTooltip) {
          return;
        }
        layer.areaTooltip = L2.tooltip({
          permanent: true,
          direction: "center",
          className: "area-tooltip"
        });
        layer.on("remove", function(event) {
          layer.areaTooltip.remove();
        });
        layer.on("add", (event) => {
          updateAreaTooltip(layer);
          layer.areaTooltip.addTo(this.map);
        });
        if (this.map.hasLayer(layer)) {
          updateAreaTooltip(layer);
          layer.areaTooltip.addTo(this.map);
        }
      };
      const updateAreaTooltip = (layer) => {
        var area = window.L.GeometryUtil.geodesicArea(
          layer.getLatLngs()[0]
        );
        var readableArea = window.L.GeometryUtil.readableArea(
          area,
          true
        );
        var latlng = layer.getCenter();
        layer.areaTooltip.setContent(readableArea).setLatLng(latlng);
      };
      console.log("Cek state");
      console.log($wire.get(config.statePath));
      console.log("Cek polygon");
      console.log($wire.get(config.statePath).polygon);
      let polygonMauCetak = [];
      for (let koordinat of $wire.get(config.statePath).polygon) {
        polygonMauCetak.push([koordinat.lat, koordinat.lng]);
      }
      let polygon2 = L2.polygon(polygonMauCetak).addTo(this.map);
      createAreaTooltip(polygon2);
      var drawnItems = L2.featureGroup().addTo(this.map);
      this.map.addControl(
        new L2.Control.Draw({
          edit: {
            featureGroup: drawnItems,
            poly: {
              allowIntersection: false
            }
          },
          draw: {
            marker: false,
            circle: false,
            circlemarker: false,
            rectangle: false,
            polyline: false,
            polygon: {
              allowIntersection: false,
              showArea: true
            }
          }
        })
      );
      this.map.on(window.L.Draw.Event.CREATED, (event) => {
        var layer = event.layer;
        if (layer instanceof L2.Polygon) {
          createAreaTooltip(layer);
        }
        drawnItems.addLayer(layer);
        this.polygon = event.layer["_latlngs"][0];
        $wire.set(
          config.statePath,
          {
            lat: config.statePath.lat,
            lng: config.statePath.lng,
            polygon: this.polygon
          },
          false
        );
        console.log($wire.get(config.statePath));
        $wire.$refresh();
      });
      this.map.on(window.L.Draw.Event.EDITED, function(event) {
        event.layers.getLayers().forEach(function(layer) {
          if (layer instanceof L2.Polygon) {
            updateAreaTooltip(layer);
          }
        });
      });
    },
    removeMap: function(el) {
      if (this.marker) {
        this.marker.remove();
        this.marker = null;
      }
      this.tile.remove();
      this.tile = null;
      this.map.off();
      this.map.remove();
      this.map = null;
    },
    getCoordinates: function() {
      let location = $wire.get(config.statePath);
      if (location === null || !location.hasOwnProperty("lat")) {
        location = { lat: 0, lng: 0, polygon: [] };
      }
      return location;
    },
    attach: function(el) {
      this.createMap(el);
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.intersectionRatio > 0) {
              if (!this.map) this.createMap(el);
            } else {
              this.removeMap(el);
            }
          });
        },
        {
          root: null,
          // set document viewport as root
          rootMargin: "0px",
          // margin around root
          threshold: 1
          // 1.0 means that when 100% of the target is visible
        }
      );
      observer.observe(el);
    }
  };
};
window.dispatchEvent(new CustomEvent("map-script-loaded"));
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvVXRpbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9DbGFzcy5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9FdmVudHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1BvaW50LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmdCb3VuZHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmcuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQnJvd3Nlci5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21VdGlsLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0hhbmRsZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9EcmFnZ2FibGUuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1BvbHlVdGlsLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0dlb0pTT04uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9TVkdPdmVybGF5LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9EaXZPdmVybGF5LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Qb3B1cC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVG9vbHRpcC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbGVhZmxldEAxLjkuNC9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXRAMS45LjQvbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXBIb2xkLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sZWFmbGV0QDEuOS40L25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCAiLi4vanMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xlYWZsZXQtZnVsbHNjcmVlbkAxLjAuMi9ub2RlX21vZHVsZXMvbGVhZmxldC1mdWxsc2NyZWVuL2Rpc3QvTGVhZmxldC5mdWxsc2NyZWVuLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5leHBvcnQgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBGKCkge31cclxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4vLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRpZiAoZm4uYmluZCkge1xyXG5cdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbi8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbmV4cG9ydCB2YXIgbGFzdElkID0gMDtcclxuXHJcbi8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG5cdGlmICghKCdfbGVhZmxldF9pZCcgaW4gb2JqKSkge1xyXG5cdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcblx0fVxyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbi8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4vLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4vLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB3cmFwcGVyRm47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbi8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5leHBvcnQgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4vLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbi8vIFRoZSBkZWZhdWx0IGBwcmVjaXNpb25gIHZhbHVlIGlzIDYgZGVjaW1hbCBwbGFjZXMuXHJcbi8vIGBmYWxzZWAgY2FuIGJlIHBhc3NlZCB0byBza2lwIGFueSBwcm9jZXNzaW5nIChjYW4gYmUgdXNlZnVsIHRvIGF2b2lkIHJvdW5kLW9mZiBlcnJvcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgcHJlY2lzaW9uKSB7XHJcblx0aWYgKHByZWNpc2lvbiA9PT0gZmFsc2UpIHsgcmV0dXJuIG51bTsgfVxyXG5cdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0fVxyXG5cdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4vLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbi8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbi8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdHZhciBwYXJhbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxufVxyXG5cclxudmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18gLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzKTtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRVdGlsLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuXHRkZWxldGUgcHJvdG8uaW5jbHVkZXM7XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvdG8ub3B0aW9ucyA9IHBhcmVudFByb3RvLm9wdGlvbnMgPyBVdGlsLmNyZWF0ZShwYXJlbnRQcm90by5vcHRpb25zKSA6IHt9O1xyXG5cdFx0VXRpbC5leHRlbmQocHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuXHRcdHRoaXMucHJvdG90eXBlLm9wdGlvbnMgPSBwYXJlbnRPcHRpb25zO1xyXG5cdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0dmFyIHJlbW92ZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZW1vdmVBbGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBfb25jZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcblx0XHRpZiAoX29uY2UpIHtcclxuXHRcdFx0bmV3TGlzdGVuZXIub25jZSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIHJlbW92ZSBhbGxcclxuXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wXHJcblx0XHRcdFx0Ly8gc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCk7XHJcblx0XHRpZiAoaW5kZXggIT09IGZhbHNlKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpbmRleF07XHJcblx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRsaXN0ZW5lci5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHQvLyBvZmYgb3ZlcndyaXRlcyBsLmZuLCBzbyB3ZSBuZWVkIHRvIGNvcHkgZm4gdG8gYSB2YXJcclxuXHRcdFx0XHRcdHZhciBmbiA9IGwuZm47XHJcblx0XHRcdFx0XHRpZiAobC5vbmNlKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIGZuLCBsLmN0eCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHQvLyBUaGUgdmVyaWZpY2F0aW9uIGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQsIGl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiBwYXJlbnRzIGhhdmUgdGhlIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignXCJzdHJpbmdcIiB0eXBlIGFyZ3VtZW50IGV4cGVjdGVkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbnB1dCBgZm5gIHZhbHVlLCBiZWNhdXNlIHdlIG5lZWQgdG8gdXNlIGl0IGZvciBwcm9wYWdhdGlvblxyXG5cdFx0dmFyIF9mbiA9IGZuO1xyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRwcm9wYWdhdGUgPSAhIWZuO1xyXG5cdFx0XHRfZm4gPSB1bmRlZmluZWQ7XHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgX2ZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIHRoZSBpbmRleCAobnVtYmVyKSBvciBmYWxzZVxyXG5cdF9saXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHRyZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0LCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG4iLCAiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufVxyXG5cclxudmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKGlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG4iLCAiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluMiwgbWF4MjtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4MiA9IG9iai5tYXg7XHJcblxyXG5cdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBtYXgyLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KG1heDIueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdG1heCA9IHRoaXMubWF4LFxyXG5cdFx0aGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMobWluLnggLSBtYXgueCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFxyXG5cdFx0XHR0b1BvaW50KG1pbi54IC0gaGVpZ2h0QnVmZmVyLCBtaW4ueSAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcblx0XHRcdHRoaXMubWF4LmVxdWFscyhib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSk7XHJcblx0fSxcclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwgImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9jcnMvQ1JTLkVhcnRoJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuIiwgIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYXRpYWxfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCAiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG5cdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcblx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuXHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblx0XHRyZXR1cm4gdGhpcy5SICogYztcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogZWFydGhSYWRpdXMsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuIiwgImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCAiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0czODU3ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBFUFNHOTAwOTEzID0gVXRpbC5leHRlbmQoe30sIEVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuIiwgImltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cbiIsICJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG52YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG52YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG52YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbnZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbnZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG52YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG52YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG52YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxudmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbnZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbnZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbnZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbnZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4vLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG52YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG52YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyAqKlRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbioqIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbnZhciB0b3VjaE5hdGl2ZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbi8vIE5vdGU6IHBvaW50ZXIgZXZlbnRzIHdpbGwgYmUgcHJlZmVycmVkIChpZiBhdmFpbGFibGUpLCBhbmQgcHJvY2Vzc2VkIGZvciBhbGwgYHRvdWNoKmAgbGlzdGVuZXJzLlxyXG52YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxudmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG52YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbnZhciBpbmxpbmVTdmcgPSAhIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcblx0cmV0dXJuIChkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG59KSgpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbnZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxudmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBMaW51eCBwbGF0Zm9ybVxyXG52YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aWU6IGllLFxyXG5cdGllbHQ5OiBpZWx0OSxcclxuXHRlZGdlOiBlZGdlLFxyXG5cdHdlYmtpdDogd2Via2l0LFxyXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXHJcblx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcblx0b3BlcmE6IG9wZXJhLFxyXG5cdGNocm9tZTogY2hyb21lLFxyXG5cdGdlY2tvOiBnZWNrbyxcclxuXHRzYWZhcmk6IHNhZmFyaSxcclxuXHRwaGFudG9tOiBwaGFudG9tLFxyXG5cdG9wZXJhMTI6IG9wZXJhMTIsXHJcblx0d2luOiB3aW4sXHJcblx0aWUzZDogaWUzZCxcclxuXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHRhbnkzZDogYW55M2QsXHJcblx0bW9iaWxlOiBtb2JpbGUsXHJcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcblx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxyXG5cdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG5cdHBvaW50ZXI6IHBvaW50ZXIsXHJcblx0dG91Y2g6IHRvdWNoLFxyXG5cdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcblx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxyXG5cdHJldGluYTogcmV0aW5hLFxyXG5cdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcblx0Y2FudmFzOiBjYW52YXMsXHJcblx0c3ZnOiBzdmcsXHJcblx0dm1sOiB2bWwsXHJcblx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcblx0bWFjOiBtYWMsXHJcblx0bGludXg6IGxpbnV4XHJcbn07XHJcbiIsICJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge2ZhbHNlRm59IGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cbnZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG52YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xudmFyIHBFdmVudCA9IHtcblx0dG91Y2hzdGFydCAgOiBQT0lOVEVSX0RPV04sXG5cdHRvdWNobW92ZSAgIDogUE9JTlRFUl9NT1ZFLFxuXHR0b3VjaGVuZCAgICA6IFBPSU5URVJfVVAsXG5cdHRvdWNoY2FuY2VsIDogUE9JTlRFUl9DQU5DRUxcbn07XG52YXIgaGFuZGxlID0ge1xuXHR0b3VjaHN0YXJ0ICA6IF9vblBvaW50ZXJTdGFydCxcblx0dG91Y2htb3ZlICAgOiBfaGFuZGxlUG9pbnRlcixcblx0dG91Y2hlbmQgICAgOiBfaGFuZGxlUG9pbnRlcixcblx0dG91Y2hjYW5jZWwgOiBfaGFuZGxlUG9pbnRlclxufTtcbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpO1xuXHR9XG5cdGlmICghaGFuZGxlW3R5cGVdKSB7XG5cdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG5cdFx0cmV0dXJuIGZhbHNlRm47XG5cdH1cblx0aGFuZGxlciA9IGhhbmRsZVt0eXBlXS5iaW5kKHRoaXMsIGhhbmRsZXIpO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcblx0cmV0dXJuIGhhbmRsZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmICghcEV2ZW50W3R5cGVdKSB7XG5cdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG5cdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpIHtcblx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG5cdGUudG91Y2hlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG5cdH1cblx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRoYW5kbGVyKGUpO1xufVxuXG5mdW5jdGlvbiBfb25Qb2ludGVyU3RhcnQoaGFuZGxlciwgZSkge1xuXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcblx0aWYgKGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggJiYgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkge1xuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9XG5cdF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpO1xufVxuIiwgImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBOb3RlOiBjdXJyZW50bHkgbW9zdCBicm93c2VycyBmaXJlIG5hdGl2ZSBkYmxjbGljaywgd2l0aCBvbmx5IGEgZmV3IGV4Y2VwdGlvbnNcclxuICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy83MDEyI2lzc3VlY29tbWVudC01OTUwODczODYpXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFrZURibGNsaWNrKGV2ZW50KSB7XHJcblx0Ly8gaW4gbW9kZXJuIGJyb3dzZXJzIGB0eXBlYCBjYW5ub3QgYmUganVzdCBvdmVycmlkZGVuOlxyXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG5cdHZhciBuZXdFdmVudCA9IHt9LFxyXG5cdCAgICBwcm9wLCBpO1xyXG5cdGZvciAoaSBpbiBldmVudCkge1xyXG5cdFx0cHJvcCA9IGV2ZW50W2ldO1xyXG5cdFx0bmV3RXZlbnRbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZChldmVudCkgOiBwcm9wO1xyXG5cdH1cclxuXHRldmVudCA9IG5ld0V2ZW50O1xyXG5cdG5ld0V2ZW50LnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcblx0bmV3RXZlbnQuaXNUcnVzdGVkID0gZmFsc2U7XHJcblx0bmV3RXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7IC8vIGZvciBkZWJ1ZyBwdXJwb3Nlc1xyXG5cdHJldHVybiBuZXdFdmVudDtcclxufVxyXG5cclxudmFyIGRlbGF5ID0gMjAwO1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKSB7XHJcblx0Ly8gTW9zdCBicm93c2VycyBoYW5kbGUgZG91YmxlIHRhcCBuYXRpdmVseVxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuXHQvLyBPbiBzb21lIHBsYXRmb3JtcyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgbmF0aXZlIGRibGNsaWNrcyBmb3IgdG91Y2ggZXZlbnRzLlxyXG5cdC8vIEl0IHNlZW1zIHRoYXQgaW4gYWxsIHN1Y2ggY2FzZXMgYGRldGFpbGAgcHJvcGVydHkgb2YgYGNsaWNrYCBldmVudCBpcyBhbHdheXMgYDFgLlxyXG5cdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcblx0dmFyIGxhc3QgPSAwLFxyXG5cdCAgICBkZXRhaWw7XHJcblx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG5cdFx0aWYgKGUuZGV0YWlsICE9PSAxKSB7XHJcblx0XHRcdGRldGFpbCA9IGUuZGV0YWlsOyAvLyBrZWVwIGluIHN5bmMgdG8gYXZvaWQgZmFsc2UgZGJsY2xpY2sgaW4gc29tZSBjYXNlc1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcclxuXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdoZW4gY2xpY2tpbmcgb24gYW4gPGlucHV0PiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGEgY2xpY2sgb24gaXRzXHJcblx0XHQvLyA8bGFiZWw+IChhbmQgdmljZSB2ZXJzYSkgdHJpZ2dlcmluZyB0d28gY2xpY2tzIGluIHF1aWNrIHN1Y2Nlc3Npb24uXHJcblx0XHQvLyBUaGlzIGlnbm9yZXMgY2xpY2tzIG9uIGVsZW1lbnRzIHdoaWNoIGFyZSBhIGxhYmVsIHdpdGggYSAnZm9yJ1xyXG5cdFx0Ly8gYXR0cmlidXRlIChvciBjaGlsZHJlbiBvZiBzdWNoIGEgbGFiZWwpLCBidXQgbm90IGNoaWxkcmVuIG9mXHJcblx0XHQvLyBhIDxpbnB1dD4uXHJcblx0XHR2YXIgcGF0aCA9IERvbUV2ZW50LmdldFByb3BhZ2F0aW9uUGF0aChlKTtcclxuXHRcdGlmIChwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQgJiYgZWwuYXR0cmlidXRlcy5mb3I7XHJcblx0XHR9KSAmJlxyXG5cdFx0XHQhcGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHxcclxuXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuXHRcdGlmIChub3cgLSBsYXN0IDw9IGRlbGF5KSB7XHJcblx0XHRcdGRldGFpbCsrO1xyXG5cdFx0XHRpZiAoZGV0YWlsID09PSAyKSB7XHJcblx0XHRcdFx0aGFuZGxlcihtYWtlRGJsY2xpY2soZSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZXRhaWwgPSAxO1xyXG5cdFx0fVxyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbURibGNsaWNrKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGRibGNsaWNrOiBoYW5kbGVyLFxyXG5cdFx0c2ltRGJsY2xpY2s6IHNpbURibGNsaWNrXHJcblx0fTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcnMpIHtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVycy5kYmxjbGljayk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcnMuc2ltRGJsY2xpY2spO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChCcm93c2VyLmFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuZXhwb3J0IHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuXHRkbyB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG5cdHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbi8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4vLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG4iLCAiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcbmltcG9ydCB7Z2V0U2NhbGV9IGZyb20gJy4vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZyk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgb2YgZ2l2ZW4gdHlwZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIGZyb20gZ2l2ZW4gSFRNTEVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0YmF0Y2hSZW1vdmUob2JqKTtcclxuXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHJcblx0fSBlbHNlIGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0YmF0Y2hSZW1vdmUob2JqLCBmdW5jdGlvbiAodHlwZSkge1xyXG5cdFx0XHRcdHJldHVybiBVdGlsLmluZGV4T2YodHlwZXMsIHR5cGUpICE9PSAtMTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYmF0Y2hSZW1vdmUob2JqLCBmaWx0ZXJGbikge1xyXG5cdGZvciAodmFyIGlkIGluIG9ialtldmVudHNLZXldKSB7XHJcblx0XHR2YXIgdHlwZSA9IGlkLnNwbGl0KC9cXGQvKVswXTtcclxuXHRcdGlmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4odHlwZSkpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgbnVsbCwgbnVsbCwgaWQpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxudmFyIG1vdXNlU3Vic3QgPSB7XHJcblx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcblx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0fTtcclxuXHJcblx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG5cdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcblx0XHRoYW5kbGVyID0gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuXHRcdGhhbmRsZXIgPSBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCwgaWQpIHtcclxuXHRpZCA9IGlkIHx8IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHR2YXIgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4vLyBgYGBqc1xyXG4vLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbi8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4vLyB9KTtcclxuLy8gYGBgXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnd2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICd3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZGJsY2xpY2snYCwgYCdjb250ZXh0bWVudSdgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10gPSB0cnVlO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXY6IERPTUV2ZW50KTogQXJyYXlcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW2BFdmVudC5jb21wb3NlZFBhdGgoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudC9jb21wb3NlZFBhdGgpLlxyXG4vLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGBIVE1MRWxlbWVudGBzIHRoYXQgdGhlIGdpdmVuIERPTSBldmVudFxyXG4vLyBzaG91bGQgcHJvcGFnYXRlIHRvIChpZiBub3Qgc3RvcHBlZCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXYpIHtcclxuXHRpZiAoZXYuY29tcG9zZWRQYXRoKSB7XHJcblx0XHRyZXR1cm4gZXYuY29tcG9zZWRQYXRoKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcGF0aCA9IFtdO1xyXG5cdHZhciBlbCA9IGV2LnRhcmdldDtcclxuXHJcblx0d2hpbGUgKGVsKSB7XHJcblx0XHRwYXRoLnB1c2goZWwpO1xyXG5cdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRyZXR1cm4gcGF0aDtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG5cclxuLy8gIGV4Y2VwdCAsIFNhZmFyaSBhbmRcclxuLy8gV2UgbmVlZCBkb3VibGUgdGhlIHNjcm9sbCBwaXhlbHMgKHNlZSAjNzQwMyBhbmQgIzQ1MzgpIGZvciBhbGwgQnJvd3NlcnNcclxuLy8gZXhjZXB0IE9TWCAoTWFjKSAtPiAzeCwgQ2hyb21lIHJ1bm5pbmcgb24gTGludXggMXhcclxuXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci5saW51eCAmJiBCcm93c2VyLmNocm9tZSkgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0QnJvd3Nlci5tYWMgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAqIDMgOlxyXG5cdHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMCA/IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIHdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbi8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbi8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHQgICAgICAgMDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG4iLCAiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteVBvc2l0aW9uTWFya2VyID0gTC5tYXJrZXIoWzQ4Ljg2NDcxNiwgMi4yOTQ2OTRdKS5hZGRUbyhtYXApO1xuICpcbiAqIG15UG9zaXRpb25NYXJrZXIub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAqIFx0dmFyIHBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobXlQb3NpdGlvbk1hcmtlci5nZXRMYXRMbmcoKSk7XG4gKiBcdHBvcy55IC09IDI1O1xuICogXHR2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqXG4gKiBcdGZ4Lm9uY2UoJ2VuZCcsZnVuY3Rpb24oKSB7XG4gKiBcdFx0cG9zLnkgKz0gMjU7XG4gKiBcdFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC44KTtcbiAqIFx0fSk7XG4gKlxuICogXHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjMpO1xuICogfSk7XG4gKlxuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbmV4cG9ydCB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwczovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5saXN0ZW5zKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSkge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG5cdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBEb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBub01vdmVTdGFydClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEsIHN1cHJlc3NFdmVudCkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcblx0XHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcblx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcblx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG5cdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG5cdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHBzOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgdGhpcy5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbCAmJiBlbCAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG5cdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuXHRcdFx0dmFyIGZpbHRlcmVkID0gW107IC8vIHBpY2sgb25seSB0YXJnZXRzIHdpdGggbGlzdGVuZXJzXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goY2FudmFzVGFyZ2V0c1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRhcmdldHMgPSBmaWx0ZXJlZC5jb25jYXQodGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0IHx8IGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcblx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLl90ZW1wRmlyZVpvb21FdmVudDtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwgIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgT3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuIiwgIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG5cdFx0Ly8gaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBjb250cm9sLlxyXG5cdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG5cdFx0Ly8gQSBbY29tcGFyZSBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydClcclxuXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuXHRcdC8vIGBzb3J0RnVuY3Rpb24obGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQilgLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcblx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcblx0XHRcdHJldHVybiBuYW1lQSA8IG5hbWVCID8gLTEgOiAobmFtZUIgPCBuYW1lQSA/IDEgOiAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuX2V4cGFuZFNhZmVseSxcclxuXHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24obGluaywge1xyXG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIENlcnRhaW4gc2NyZWVuIHJlYWRlcnMgaW50ZXJjZXB0IHRoZSBrZXkgZXZlbnQgYW5kIGluc3RlYWQgc2VuZCBhIGNsaWNrIGV2ZW50XHJcblx0XHRcdGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcblx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcblx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcblx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuXHRcdCAgICBpbnB1dDtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgVXRpbC5zdGFtcCh0aGlzKSwgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IFV0aWwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHREb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZXhwYW5kaW5nIHRoZSBjb250cm9sIG9uIG1vYmlsZSB3aXRoIGEgY2xpY2sgY2FuIGNhdXNlIGFkZGluZyBhIGxheWVyIC0gd2UgZG9uJ3Qgd2FudCB0aGlzXHJcblx0XHRpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRTYWZlbHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbjtcclxuXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XHJcblx0XHREb21FdmVudC5vbihzZWN0aW9uLCAnY2xpY2snLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihzZWN0aW9uLCAnY2xpY2snLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHRcdHRoYXQuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICogQGluaGVyaXRzIENvbnRyb2xcbiAqXG4gKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG59O1xuIiwgIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbnZhciB1a3JhaW5pYW5GbGFnID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI4XCIgdmlld0JveD1cIjAgMCAxMiA4XCIgY2xhc3M9XCJsZWFmbGV0LWF0dHJpYnV0aW9uLWZsYWdcIj48cGF0aCBmaWxsPVwiIzRDN0JFMVwiIGQ9XCJNMCAwaDEydjRIMHpcIi8+PHBhdGggZmlsbD1cIiNGRkQ1MDBcIiBkPVwiTTAgNGgxMnYzSDB6XCIvPjxwYXRoIGZpbGw9XCIjRTBCQzAwXCIgZD1cIk0wIDdoMTJ2MUgwelwiLz48L3N2Zz4nO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmd8ZmFsc2UgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdG1hcC5vbignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2FkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoZXYpIHtcclxuXHRcdGlmIChldi5sYXllci5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHRldi5sYXllci5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcblx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCcmY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcbiIsICJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCAiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbmV4cG9ydCB2YXIgSGFuZGxlciA9IENsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbi8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbkhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG5cdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG4iLCAiaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcbiIsICJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcblx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdHZhciBtb3VzZWV2ZW50ID0gZS50eXBlID09PSAnbW91c2Vkb3duJztcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHJcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdG5vSW5lcnRpYTogbm9JbmVydGlhLFxyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufSk7XHJcbiIsICJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vKiBAZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5Z29uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcblx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyO1xyXG5cclxuXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIUxpbmVVdGlsLmlzRmxhdChsYXRsbmdzKSkge1xyXG5cdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG5cdH1cclxuXHJcblx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcblx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG5cdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcblx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG5cdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG5cdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcblx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG5cdH1cclxuXHJcblx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuXHR9XHJcblxyXG5cdGFyZWEgPSB4ID0geSA9IDA7XHJcblxyXG5cdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtO1xyXG5cdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRwMSA9IHBvaW50c1tpXTtcclxuXHRcdHAyID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xyXG5cdFx0eCArPSAocDEueCArIHAyLngpICogZjtcclxuXHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XHJcblx0XHRhcmVhICs9IGYgKiAzO1xyXG5cdH1cclxuXHJcblx0aWYgKGFyZWEgPT09IDApIHtcclxuXHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxyXG5cdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBjZW50cm9pZChsYXRsbmdzOiBMYXRMbmdbXSk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSAnY2VudGVyIG9mIG1hc3MnIG9mIHRoZSBwYXNzZWQgTGF0TG5ncy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjZW50cm9pZChjb29yZHMpIHtcclxuXHR2YXIgbGF0U3VtID0gMDtcclxuXHR2YXIgbG5nU3VtID0gMDtcclxuXHR2YXIgbGVuID0gMDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRsYXRTdW0gKz0gbGF0bG5nLmxhdDtcclxuXHRcdGxuZ1N1bSArPSBsYXRsbmcubG5nO1xyXG5cdFx0bGVuKys7XHJcblx0fVxyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0U3VtIC8gbGVuLCBsbmdTdW0gLyBsZW5dKTtcclxufVxyXG4iLCAiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7Y2VudHJvaWR9IGZyb20gJy4vUG9seVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwczovL21vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzLykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0YSA9IHA7XHJcblx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGIgPSBwO1xyXG5cdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5leHBvcnQgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0dmFyIHggPSBwMS54LFxyXG5cdCAgICB5ID0gcDEueSxcclxuXHQgICAgZHggPSBwMi54IC0geCxcclxuXHQgICAgZHkgPSBwMi55IC0geSxcclxuXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0ICAgIHQ7XHJcblxyXG5cdGlmIChkb3QgPiAwKSB7XHJcblx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0eSA9IHAyLnk7XHJcblx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR4ID0gcC54IC0geDtcclxuXHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlsaW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG5cdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbywgY2VudGVyO1xyXG5cclxuXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWlzRmxhdChsYXRsbmdzKSkge1xyXG5cdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG5cdH1cclxuXHJcblx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcblx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG5cdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcblx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG5cdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG5cdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcblx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG5cdH1cclxuXHJcblx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG5cdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxyXG5cdGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG5cdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcclxuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xyXG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcclxuXHJcblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcclxuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcclxuXHRcdFx0XHRjZW50ZXIgPSBbXHJcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxyXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxyXG5cdFx0XHRcdF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbn1cclxuIiwgImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsICJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpcyBhbiBlbGxpcHNvaWQuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG4iLCAiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICovXG5cbmV4cG9ydCB7TG9uTGF0fSBmcm9tICcuL1Byb2plY3Rpb24uTG9uTGF0JztcbmV4cG9ydCB7TWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5NZXJjYXRvcic7XG5leHBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xuIiwgImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsICJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0c0MzI2ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG4iLCAiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxuZXhwb3J0IHZhciBTaW1wbGUgPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHByb2plY3Rpb246IExvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuIiwgImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCAiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHQvL1xuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBgTGF5ZXJHcm91cGBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycztcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcbiIsICJcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHRcdHJldHVybiBsYXllcklkIGluIHRoaXMuX2xheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsICJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsICJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxufVxyXG4iLCAiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcblx0XHR2YXIgc3RyaXAgPSBmdW5jdGlvbiAoc3RyLCByZSwgaWR4KSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG5cdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcblx0XHR9O1xuXHRcdHBhdGggPSBzdHJpcChwYXRoLCAvXnVybFxcKChbJ1wiXSk/KC4rKVxcMVxcKSQvLCAyKTtcblx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdHBhdGggPSB0aGlzLl9zdHJpcFVybChwYXRoKTtcblx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuXHRcdHZhciBsaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmJD1cImxlYWZsZXQuY3NzXCJdJyk7XG5cdFx0aWYgKCFsaW5rKSB7IHJldHVybiAnJzsgfVxuXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuXHR9XG59KTtcbiIsICJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG5cdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuXHRcdHRoaXMuX21hcmtlclxuXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCB7TWFya2VyRHJhZ30gZnJvbSAnLi9NYXJrZXIuRHJhZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJ01hcmtlcidcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcblx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuXHRcdGFsdDogJ01hcmtlcicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1Bhbk9uRm9jdXM6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgdGhlIG1hcCB3aWxsIHBhbiB3aGVuZXZlciB0aGUgbWFya2VyIGlzIGZvY3VzZWQgKHZpYVxyXG5cdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcblx0XHQvLyB2aXNpYmxlIHdpdGhpbiB0aGUgbWFwJ3MgYm91bmRzXHJcblx0XHRhdXRvUGFuT25Gb2N1czogdHJ1ZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHRcdGljb24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZih0aGlzLl9pY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbk9uRm9jdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgaWNvbk9wdHMgPSB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHBvaW50KGljb25PcHRzLmljb25TaXplKSA6IHBvaW50KDAsIDApO1xyXG5cdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyBwb2ludChpY29uT3B0cy5pY29uQW5jaG9yKSA6IHBvaW50KDAsIDApO1xyXG5cclxuXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcblx0XHRcdHBhZGRpbmdUb3BMZWZ0OiBhbmNob3IsXHJcblx0XHRcdHBhZGRpbmdCb3R0b21SaWdodDogc2l6ZS5zdWJ0cmFjdChhbmNob3IpXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuIiwgImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgK1xuXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuXHR9XG59KTtcbiIsICJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCAiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG4iLCAiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gKiBcdFszNy43NywgLTEyMi40M10sXG4gKiBcdFszNC4wNCwgLTExOC4yXVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcblx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cdFx0cmV0dXJuIExpbmVVdGlsLnBvbHlsaW5lQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdGlmICghdGhpcy5fcmF3UHhCb3VuZHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuXHRcdF0pO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuIiwgImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgUG9seWdvbi5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblx0XHRyZXR1cm4gUG9seVV0aWwucG9seWdvbkNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge01hcmtlcn0gZnJvbSAnLi9tYXJrZXIvTWFya2VyJztcclxuaW1wb3J0IHtDaXJjbGV9IGZyb20gJy4vdmVjdG9yL0NpcmNsZSc7XHJcbmltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGVNYXJrZXInO1xyXG5pbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL3ZlY3Rvci9Qb2x5bGluZSc7XHJcbmltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi92ZWN0b3IvUG9seWdvbic7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4vLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHQgICAgbGF5ZXJzID0gW10sXHJcblx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRjYXNlICdQb2ludCc6XHJcblx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdQb2x5Z29uJzpcclxuXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgZ2VvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAoZ2VvTGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChnZW9MYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBmZWF0dXJlTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvbWV0cnkuZmVhdHVyZXNbaV0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGZlYXR1cmVMYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGZlYXR1cmVMYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGRlZmF1bHQ6XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG5cdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcblx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4vLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbi8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXRsbmdzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbildO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdC8vIENoZWNrIGZvciBmbGF0IGFycmF5cyByZXF1aXJlZCB0byBlbnN1cmUgdW5iYWxhbmNlZCBhcnJheXMgYXJlIGNvcnJlY3RseSBjb252ZXJ0ZWQgaW4gcmVjdXJzaW9uXHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIExpbmVVdGlsLmlzRmxhdChsYXRsbmdzW2ldKSA/IDAgOiBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0uc2xpY2UoKSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5leHBvcnQgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcblx0Ly8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbmV4cG9ydCB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XHJcbiIsICJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGltYWdlLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIG92ZXJsYXkgbGF5ZXIuXHJcblx0XHR6SW5kZXg6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgnaW1nJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gVXRpbC5iaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG5cdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzLmdldENlbnRlcigpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIFNlZSBbYnJvd3NlciBjb21wYXRpYmlsaXR5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdClcclxuXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG5cdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBNb2JpbGUgYnJvd3NlcnMgd2lsbCBwbGF5IHRoZSB2aWRlbyByaWdodCB3aGVyZSBpdCBpcyBpbnN0ZWFkIG9mIG9wZW4gaXQgdXAgaW4gZnVsbHNjcmVlbiBtb2RlLlxyXG5cdFx0cGxheXNJbmxpbmU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuXHRcdH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcblx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsICJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICogQGFrYSBMLlNWR092ZXJsYXlcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAqXG4gKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICpcbiAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5faW1hZ2UgPSB0aGlzLl91cmw7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cblxuXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0ZWwub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cdH1cblxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4vLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZywgTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gb3ZlcmxheXMgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5leHBvcnQgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCB0aGUgcG9wdXAvdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgbW91c2UgZXZlbnRzLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBvc2l0aW9uLlxyXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIG92ZXJsYXkuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24gPSAnJ1xyXG5cdFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5IHdoaWxlIGluaXRpYWxpemluZy4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlXHJcblx0XHQvLyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuXHRcdGNvbnRlbnQ6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0aWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMgaW5zdGFuY2VvZiBMYXRMbmcgfHwgVXRpbC5pc0FycmF5KG9wdGlvbnMpKSkge1xyXG5cdFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhvcHRpb25zKTtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHNvdXJjZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG5cdFx0XHR0aGlzLl9jb250ZW50ID0gdGhpcy5vcHRpb25zLmNvbnRlbnQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgb3ZlcmxheSB0byB0aGUgbWFwLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2UoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLmNsb3NlUG9wdXAocG9wdXApYC9gLmNsb3NlVG9vbHRpcCh0b29sdGlwKWBcclxuXHQvLyBhbmQgYGxheWVyLmNsb3NlUG9wdXAoKWAvYC5jbG9zZVRvb2x0aXAoKWAuXHJcblx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdC8vIEFyZ3VtZW50IG1heSBiZSBvbWl0dGVkIG9ubHkgZm9yIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuXHR0b2dnbGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxheWVyID0gdGhpcy5fc291cmNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3ByZXBhcmVPcGVuKCk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBvdmVybGF5IG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKERvbVV0aWwucmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5LiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cclxuXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IGluIGZyb250IG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcblx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgc291cmNlID0gdGhpcy5fc291cmNlO1xyXG5cdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcblx0XHRcdHNvdXJjZSA9IG51bGw7XHJcblx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XHJcblx0XHRcdFx0aWYgKGxheWVyc1tpZF0uX21hcCkge1xyXG5cdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIXNvdXJjZSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIuXHJcblxyXG5cdFx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0Qm91bmRzKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldExhdExuZyhsYXRsbmcpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgY29udGVudHVwZGF0ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkgaXMgdXBkYXRlZFxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgb3ZlcmxheSBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5NYXAuaW5jbHVkZSh7XHJcblx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBjb250ZW50LCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcblx0XHRcdG92ZXJsYXkgPSBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF0bG5nKSB7XHJcblx0XHRcdG92ZXJsYXkuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3ZlcmxheTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbkxheWVyLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgb2xkLCBjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcblx0XHRcdG92ZXJsYXkuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG5cdFx0XHRvdmVybGF5LnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3ZlcmxheTtcclxuXHR9XHJcbn0pO1xyXG4iLCAiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICpcclxuICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICogb3JcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdC8vIFRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBjYW4gYmUgc3R5bGVkIHVzaW5nIHRoZVxyXG5cdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGV2KTtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcblx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuXHRcdGlmICh0aGlzLl9hdXRvcGFubmluZykge1xyXG5cdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChEb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX3BvcHVwID0gdGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHRoaXMuX3BvcHVwLCBjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG5cdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuIiwgImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSB0b29sdGlwIHRvIG1hcmtlcjpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRUb29sdGlwYCBtZXRob2QuXG4gKlxuICogQSB0b29sdGlwIGNhbiBiZSBhbHNvIHN0YW5kYWxvbmU6XG4gKlxuICogYGBganNcbiAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKClcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXG4gKiBcdC5zZXRDb250ZW50KCdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLicpXG4gKiBcdC5hZGRUbyhtYXApO1xuICogYGBgXG4gKiBvclxuICogYGBganNcbiAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKGxhdGxuZywge2NvbnRlbnQ6ICdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLid9KVxuICogXHQuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHR0aGlzLmFkZEV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdHRoaXMucmVtb3ZlRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbGVhZmxldC10b29sdGlwLScgKyBVdGlsLnN0YW1wKHRoaXMpKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgc3ViWCwgc3ViWSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGg7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cbmV4cG9ydCB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHR0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdHRvb2x0aXAuY2xvc2UoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLmlzVG9vbHRpcE9wZW4oKSkge1xuXHRcdFx0dGhpcy51bmJpbmRUb29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbHRpcCA9IHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRoaXMuX3Rvb2x0aXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKGxhdGxuZykpIHtcblx0XHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAub3Blbk9uKHRoaXMuX21hcCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuXHRcdFx0XHRcdHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIodGhpcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcblx0XHRcdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9hZGRGb2N1c0xpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcih0aGlzKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG5cdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHREb21FdmVudC5vbihlbCwgJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHREb21FdmVudC5vbihlbCwgJ2JsdXInLCB0aGlzLmNsb3NlVG9vbHRpcCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl90b29sdGlwLl9jb250YWluZXIuaWQpO1xuXHRcdH1cblx0fSxcblxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtYXAgaXMgbW92aW5nLCB3ZSB3aWxsIHNob3cgdGhlIHRvb2x0aXAgYWZ0ZXIgaXQncyBkb25lLlxuXHRcdGlmICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpICYmICF0aGlzLl9vcGVuT25jZUZsYWcpIHtcblx0XHRcdHRoaXMuX29wZW5PbmNlRmxhZyA9IHRydWU7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR0aGlzLl9tYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fb3Blbk9uY2VGbGFnID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX29wZW5Ub29sdGlwKGUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdHRoaXMub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuIiwgImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtlbXB0eX0gZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuZXhwb3J0IHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG5cdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHRlbXB0eShkaXYpO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IHBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG4iLCAiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCAiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpOyAvLyBpbXBsaWNpdCBfdXBkYXRlKCkgY2FsbFxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pIHtcblx0XHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHogPSBOdW1iZXIoeik7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdFV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X29uVXBkYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25SZW1vdmVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoTnVtYmVyKHopKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG5cdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG5cdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIGxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXHRcdHJldHVybiBbbncsIHNlXTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IFV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IFV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ30pLmFkZFRvKG1hcCk7XG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZWZlcnJlclBvbGljeTogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLlxyXG5cdFx0Ly8gVGhpcyBtYXkgYmUgbmVlZGVkIGlmIHlvdXIgbWFwJ3MgcmVuZGVyaW5nIGNvbnRleHQgaGFzIGEgc3RyaWN0IGRlZmF1bHQgYnV0IHlvdXIgdGlsZSBwcm92aWRlciBleHBlY3RzIGEgdmFsaWQgcmVmZXJyZXJcclxuXHRcdC8vIChlLmcuIHRvIHZhbGlkYXRlIGFuIEFQSSB0b2tlbikuXHJcblx0XHQvLyBSZWZlciB0byBbSFRNTEltYWdlRWxlbWVudC5yZWZlcnJlclBvbGljeV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvcmVmZXJyZXJQb2xpY3kpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0cmVmZXJyZXJQb2xpY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSAtIDEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tICsgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9IGVsc2UgaWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSBtYXhab29tIGlzIGd0ZSBtaW5ab29tXHJcblx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSBtaW5ab29tIGlzIGx0ZSBtYXhab29tXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcblx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIFV0aWwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciB0aGlzIG5ldyBvcHRpb24gd2UgZm9sbG93IHRoZSBkb2N1bWVudGVkIGJlaGF2aW9yXHJcblx0XHQvLyBtb3JlIGNsb3NlbHkgYnkgb25seSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSB3aGVuIHN0cmluZ1xyXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRpbGUucmVmZXJyZXJQb2xpY3kgPSB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3k7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGhlIGFsdCBhdHRyaWJ1dGUgaXMgc2V0IHRvIHRoZSBlbXB0eSBzdHJpbmcsXHJcblx0XHQvLyBhbGxvd2luZyBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhlIGRlY29yYXRpdmUgaW1hZ2UgdGlsZXMuXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvV0FJL3R1dG9yaWFscy9pbWFnZXMvZGVjb3JhdGl2ZS9cclxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFyaWEvI2VsLWltZy1lbXB0eS1hbHRcclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG5cdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IFV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdHZhciBjb29yZHMgPSB0aGlzLl90aWxlc1tpXS5jb29yZHM7XHJcblx0XHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuXHRcdFx0XHRcdC8vIEBldmVudCB0aWxlYWJvcnQ6IFRpbGVFdmVudFxyXG5cdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgd2FzIGxvYWRpbmcgYnV0IGlzIG5vdyBub3Qgd2FudGVkLlxyXG5cdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcblx0XHRcdFx0XHRcdHRpbGU6IHRpbGUsXHJcblx0XHRcdFx0XHRcdGNvb3JkczogY29vcmRzXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIENhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbGVcclxuXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBVdGlsLmVtcHR5SW1hZ2VVcmwpO1xyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gVXRpbC5lbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCAiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCAiZXhwb3J0IHtHcmlkTGF5ZXIsIGdyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNU30gZnJvbSAnLi9UaWxlTGF5ZXIuV01TJztcblRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG50aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuZXhwb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn07XG4iLCAiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHQvLyBhbHdheXMga2VlcCB0cmFuc2Zvcm0tb3JpZ2luIGFzIDAgMFxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChjdXJyZW50Q2VudGVyUG9pbnQpXG5cdFx0XHRcdCAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcbiIsICJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL2NhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG5cdFx0dG9sZXJhbmNlOiAwXG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwgImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBEbyBub3QgcmV0dXJuIGZuIGZyb20gY2F0Y2ggYmxvY2sgc28gYGVgIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvNzI3OVxuXHR9XG5cdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0fTtcbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcbiIsICJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge3N0YW1wfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtzdmdDcmVhdGUsIHBvaW50c1RvUGF0aH0gZnJvbSAnLi9TVkcuVXRpbCc7XG5leHBvcnQge3BvaW50c1RvUGF0aH07XG5pbXBvcnQge3ZtbE1peGluLCB2bWxDcmVhdGV9IGZyb20gJy4vU1ZHLlZNTCc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlID0gQnJvd3Nlci52bWwgPyB2bWxDcmVhdGUgOiBzdmdDcmVhdGU7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSgnZycpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Y2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge3N2Z30gZnJvbSAnLi9TVkcnO1xuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsICJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuIiwgImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuIiwgImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcbmV4cG9ydCB7U1ZHT3ZlcmxheSwgc3ZnT3ZlcmxheX0gZnJvbSAnLi9TVkdPdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcbiIsICJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG5cdGluZXJ0aWE6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQodG9Qb2ludChvZmZzZXQpLCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0XHR2YXIgbmV3TGF0TG5nID0gbWFwLndyYXBMYXRMbmcobWFwLnVucHJvamVjdChtYXAucHJvamVjdChtYXAuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSk7XG5cdFx0XHRcdFx0bWFwLnBhblRvKG5ld0xhdExuZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2Ugd2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBEb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHREb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAqL1xuXG52YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG5cdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cblx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG5cdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuXHRcdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0fSxcblxuXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG5cdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRcdHZpZXc6IHdpbmRvdyxcblx0XHRcdC8vIGRldGFpbDogMSxcblx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcblx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcblx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcblx0XHRcdC8vIGJ1dHRvbjogMixcblx0XHRcdC8vIGJ1dHRvbnM6IDJcblx0XHR9KTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbi8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcbiIsICJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2Vycy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IFV0aWwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0sIHVuZGVmaW5lZCk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4vTWFwJztcbmltcG9ydCB7Qm94Wm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Cb3hab29tJztcbk1hcC5Cb3hab29tID0gQm94Wm9vbTtcbmltcG9ydCB7RG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbSc7XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuaW1wb3J0IHtEcmFnfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRyYWcnO1xuTWFwLkRyYWcgPSBEcmFnO1xuaW1wb3J0IHtLZXlib2FyZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5LZXlib2FyZCc7XG5NYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbmltcG9ydCB7U2Nyb2xsV2hlZWxab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbSc7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuaW1wb3J0IHtUYXBIb2xkfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcEhvbGQnO1xuTWFwLlRhcEhvbGQgPSBUYXBIb2xkO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG4iLCAiaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xuaW1wb3J0IFwibGVhZmxldC1mdWxsc2NyZWVuXCI7XG5cbndpbmRvdy5tYXBQaWNrZXIgPSAoJHdpcmUsIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgdGlsZTogbnVsbCxcbiAgICAgICAgbWFya2VyOiBudWxsLFxuICAgICAgICBwb2x5Z29uOiBbXSxcbiAgICAgICAgcmVmcmVzaE1hcCgpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2ggTWFwJylcbiAgICAgICAgICAgIHRoaXMubWFwLmZseVRvKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgICAgICAvLyB0aGlzLnVwZGF0ZU1hcmtlcigpO1xuICAgICAgICAgICAgJHdpcmUuJHJlZnJlc2goKVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVNYXA6IGZ1bmN0aW9uIChlbCkge1xuXG5cbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAkd2lyZS5vbigncmVmcmVzaE1hcCcsIHRoaXMucmVmcmVzaE1hcC5iaW5kKHRoaXMpKVxuXG4gICAgICAgICAgICB0aGlzLm1hcCA9IEwubWFwKGVsLCBjb25maWcuY29udHJvbHMpO1xuICAgICAgICAgICAgdGhpcy5tYXAub24oXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubWFwLmludmFsaWRhdGVTaXplKHRydWUpLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNob3dNYXJrZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0TGF0TG5nKHRoaXMubWFwLmdldENlbnRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFjb25maWcuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRpbGUgPSBMLnRpbGVMYXllcihjb25maWcudGlsZXNVcmwsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbjogY29uZmlnLmF0dHJpYnV0aW9uLFxuICAgICAgICAgICAgICAgIG1pblpvb206IGNvbmZpZy5taW5ab29tLFxuICAgICAgICAgICAgICAgIG1heFpvb206IGNvbmZpZy5tYXhab29tLFxuICAgICAgICAgICAgICAgIHRpbGVTaXplOiBjb25maWcudGlsZVNpemUsXG4gICAgICAgICAgICAgICAgem9vbU9mZnNldDogY29uZmlnLnpvb21PZmZzZXQsXG4gICAgICAgICAgICAgICAgZGV0ZWN0UmV0aW5hOiBjb25maWcuZGV0ZWN0UmV0aW5hLFxuICAgICAgICAgICAgfSkuYWRkVG8odGhpcy5tYXApO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnNob3dNYXJrZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJDb2xvciA9IGNvbmZpZy5tYXJrZXJDb2xvciB8fCBcIiMzYjgyZjZcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBzdmdJY29uID0gTC5kaXZJY29uKHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwibWFwLWljb25cIiBmaWxsPVwiJHttYXJrZXJDb2xvcn1cIiB3aWR0aD1cIjM2XCIgaGVpZ2h0PVwiMzZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xMiAwYy00LjE5OCAwLTggMy40MDMtOCA3LjYwMiAwIDQuMTk4IDMuNDY5IDkuMjEgOCAxNi4zOTggNC41MzEtNy4xODggOC0xMi4yIDgtMTYuMzk4IDAtNC4xOTktMy44MDEtNy42MDItOC03LjYwMnptMCAxMWMtMS42NTcgMC0zLTEuMzQzLTMtM3MxLjM0My0zIDMtMyAzIDEuMzQzIDMgMy0xLjM0MyAzLTMgM3pcIi8+PC9zdmc+YCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBpY29uU2l6ZTogWzM2LCAzNl0sXG4gICAgICAgICAgICAgICAgICAgIGljb25BbmNob3I6IFsxOCwgMzZdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB7XG4gICAgICAgICAgICAgICAgICAgIGljb246IHN2Z0ljb24sXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9QYW46IHRydWUsXG4gICAgICAgICAgICAgICAgfSkuYWRkVG8odGhpcy5tYXApO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9uKFwibW92ZVwiLCAoKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRMYXRMbmcodGhpcy5tYXAuZ2V0Q2VudGVyKCkpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubWFwLm9uKFwibW92ZWVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGVzID0gdGhpcy5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRyYWdnYWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29vcmRpbmF0ZXMubG5nICE9PSB0aGlzLm1hcC5nZXRDZW50ZXIoKVtcImxuZ1wiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMubGF0ICE9PSB0aGlzLm1hcC5nZXRDZW50ZXIoKVtcImxhdFwiXSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJHdpcmUuc2V0KGNvbmZpZy5zdGF0ZVBhdGgsIHRoaXMubWFwLmdldENlbnRlcigpLCBmYWxzZSlcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25maWcuc3RhdGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJtb3ZlZW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAkd2lyZS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogdGhpcy5tYXAuZ2V0Q2VudGVyKCkubGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogdGhpcy5tYXAuZ2V0Q2VudGVyKCkubG5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR3aXJlLmdldChjb25maWcuc3RhdGVQYXRoKS5wb2x5Z29uID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJHdpcmUuZ2V0KGNvbmZpZy5zdGF0ZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGkgc2luaSBiZXJoYXNpbFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubGl2ZUxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkd2lyZS4kcmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubWFwLm9uKFwibG9jYXRpb25mb3VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tYXAuc2V0Wm9vbShjb25maWcuY29udHJvbHMuem9vbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGlmICghbG9jYXRpb24ubGF0ICYmICFsb2NhdGlvbi5sbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5sb2NhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZXRWaWV3OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiBjb25maWcuY29udHJvbHMubWF4Wm9vbSxcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFZpZXcobmV3IEwuTGF0TG5nKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1lbmdnYW1iYXIgcG9seWdvblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQXJlYVRvb2x0aXAgPSAobGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuYXJlYVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxheWVyLmFyZWFUb29sdGlwID0gTC50b29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgcGVybWFuZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhcmVhLXRvb2x0aXBcIixcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxheWVyLm9uKFwicmVtb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5hcmVhVG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxheWVyLm9uKFwiYWRkXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBcmVhVG9vbHRpcChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmFyZWFUb29sdGlwLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcC5oYXNMYXllcihsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXJlYVRvb2x0aXAobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5hcmVhVG9vbHRpcC5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlQXJlYVRvb2x0aXAgPSAobGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgYXJlYSA9IHdpbmRvdy5MLkdlb21ldHJ5VXRpbC5nZW9kZXNpY0FyZWEoXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmdldExhdExuZ3MoKVswXSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciByZWFkYWJsZUFyZWEgPSB3aW5kb3cuTC5HZW9tZXRyeVV0aWwucmVhZGFibGVBcmVhKFxuICAgICAgICAgICAgICAgICAgICBhcmVhLFxuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIGxhdGxuZyA9IGxheWVyLmdldENlbnRlcigpO1xuXG4gICAgICAgICAgICAgICAgbGF5ZXIuYXJlYVRvb2x0aXAuc2V0Q29udGVudChyZWFkYWJsZUFyZWEpLnNldExhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDZWsgc3RhdGVcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygkd2lyZS5nZXQoY29uZmlnLnN0YXRlUGF0aCkpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNlayBwb2x5Z29uXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJHdpcmUuZ2V0KGNvbmZpZy5zdGF0ZVBhdGgpLnBvbHlnb24pO1xuXG4gICAgICAgICAgICBsZXQgcG9seWdvbk1hdUNldGFrID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBrb29yZGluYXQgb2YgJHdpcmUuZ2V0KGNvbmZpZy5zdGF0ZVBhdGgpLnBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uTWF1Q2V0YWsucHVzaChba29vcmRpbmF0LmxhdCwga29vcmRpbmF0LmxuZ10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcG9seWdvbiA9IEwucG9seWdvbihwb2x5Z29uTWF1Q2V0YWspLmFkZFRvKHRoaXMubWFwKTtcblxuICAgICAgICAgICAgY3JlYXRlQXJlYVRvb2x0aXAocG9seWdvbik7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRVhBTVBMRSBXSVRIIExFQUZMRVQgRFJBVyBDT05UUk9MXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBkcmF3bkl0ZW1zID0gTC5mZWF0dXJlR3JvdXAoKS5hZGRUbyh0aGlzLm1hcCk7XG5cbiAgICAgICAgICAgIHRoaXMubWFwLmFkZENvbnRyb2woXG4gICAgICAgICAgICAgICAgbmV3IEwuQ29udHJvbC5EcmF3KHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUdyb3VwOiBkcmF3bkl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW50ZXJzZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRyYXc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlbWFya2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbnRlcnNlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dBcmVhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKEwuRHJhdylcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKHdpbmRvdy5MLkRyYXcuRXZlbnQuQ1JFQVRFRCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gZXZlbnQubGF5ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQXJlYVRvb2x0aXAobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRyYXduSXRlbXMuYWRkTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uID0gZXZlbnQubGF5ZXJbXCJfbGF0bG5nc1wiXVswXTtcblxuICAgICAgICAgICAgICAgIC8vICR3aXJlLnNldChjb25maWcuc3RhdGVQYXRoLnBvbHlnb24sIGV2ZW50LmxheWVyWydfbGF0bG5ncyddKVxuICAgICAgICAgICAgICAgICR3aXJlLnNldChcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBjb25maWcuc3RhdGVQYXRoLmxhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogY29uZmlnLnN0YXRlUGF0aC5sbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uOiB0aGlzLnBvbHlnb24sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJHdpcmUuZ2V0KGNvbmZpZy5zdGF0ZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAkd2lyZS4kcmVmcmVzaCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubWFwLm9uKHdpbmRvdy5MLkRyYXcuRXZlbnQuRURJVEVELCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5sYXllcnMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBcmVhVG9vbHRpcChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVNYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy50aWxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWFwLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5tYXAucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvb3JkaW5hdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSAkd2lyZS5nZXQoY29uZmlnLnN0YXRlUGF0aCk7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IG51bGwgfHwgIWxvY2F0aW9uLmhhc093blByb3BlcnR5KFwibGF0XCIpKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSB7IGxhdDogMCwgbG5nOiAwLCBwb2x5Z29uOiBbXSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU1hcChlbCk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgICAgICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcCkgdGhpcy5jcmVhdGVNYXAoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb290OiBudWxsLCAvLyBzZXQgZG9jdW1lbnQgdmlld3BvcnQgYXMgcm9vdFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luOiBcIjBweFwiLCAvLyBtYXJnaW4gYXJvdW5kIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxLjAsIC8vIDEuMCBtZWFucyB0aGF0IHdoZW4gMTAwJSBvZiB0aGUgdGFyZ2V0IGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xud2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibWFwLXNjcmlwdC1sb2FkZWRcIikpO1xuIiwgIkwuQ29udHJvbC5GdWxsc2NyZWVuID0gTC5Db250cm9sLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgJ2ZhbHNlJzogJ1ZpZXcgRnVsbHNjcmVlbicsXG4gICAgICAgICAgICAndHJ1ZSc6ICdFeGl0IEZ1bGxzY3JlZW4nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtZnVsbHNjcmVlbiBsZWFmbGV0LWJhciBsZWFmbGV0LWNvbnRyb2wnKTtcblxuICAgICAgICB0aGlzLmxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJ2xlYWZsZXQtY29udHJvbC1mdWxsc2NyZWVuLWJ1dHRvbiBsZWFmbGV0LWJhci1wYXJ0JywgY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5saW5rLmhyZWYgPSAnIyc7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl90b2dnbGVUaXRsZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVRpdGxlKCk7XG5cbiAgICAgICAgTC5Eb21FdmVudC5vbih0aGlzLmxpbmssICdjbGljaycsIHRoaXMuX2NsaWNrLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB0aGlzLl9tYXAudG9nZ2xlRnVsbHNjcmVlbih0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlVGl0bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmsudGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGVbdGhpcy5fbWFwLmlzRnVsbHNjcmVlbigpXTtcbiAgICB9XG59KTtcblxuTC5NYXAuaW5jbHVkZSh7XG4gICAgaXNGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Z1bGxzY3JlZW4gfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIHRvZ2dsZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wc2V1ZG9GdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVBzZXVkb0Z1bGxzY3JlZW4oY29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlUHNldWRvRnVsbHNjcmVlbihjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wc2V1ZG9GdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlUHNldWRvRnVsbHNjcmVlbihjb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbihFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVQc2V1ZG9GdWxsc2NyZWVuKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBfZW5hYmxlUHNldWRvRnVsbHNjcmVlbjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1wc2V1ZG8tZnVsbHNjcmVlbicpO1xuICAgICAgICB0aGlzLl9zZXRGdWxsc2NyZWVuKHRydWUpO1xuICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX2Rpc2FibGVQc2V1ZG9GdWxsc2NyZWVuOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXBzZXVkby1mdWxsc2NyZWVuJyk7XG4gICAgICAgIHRoaXMuX3NldEZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX3NldEZ1bGxzY3JlZW46IGZ1bmN0aW9uKGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdGhpcy5faXNGdWxsc2NyZWVuID0gZnVsbHNjcmVlbjtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1mdWxsc2NyZWVuLW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1mdWxsc2NyZWVuLW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfb25GdWxsc2NyZWVuQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPVxuICAgICAgICAgICAgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcblxuICAgICAgICBpZiAoZnVsbHNjcmVlbkVsZW1lbnQgPT09IHRoaXMuZ2V0Q29udGFpbmVyKCkgJiYgIXRoaXMuX2lzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0RnVsbHNjcmVlbih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgICB9IGVsc2UgaWYgKGZ1bGxzY3JlZW5FbGVtZW50ICE9PSB0aGlzLmdldENvbnRhaW5lcigpICYmIHRoaXMuX2lzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0RnVsbHNjcmVlbihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGZ1bGxzY3JlZW5Db250cm9sOiBmYWxzZVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wgPSBuZXcgTC5Db250cm9sLkZ1bGxzY3JlZW4odGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wpO1xuICAgIH1cblxuICAgIHZhciBmdWxsc2NyZWVuY2hhbmdlO1xuXG4gICAgaWYgKCdvbmZ1bGxzY3JlZW5jaGFuZ2UnIGluIGRvY3VtZW50KSB7XG4gICAgICAgIGZ1bGxzY3JlZW5jaGFuZ2UgPSAnZnVsbHNjcmVlbmNoYW5nZSc7XG4gICAgfSBlbHNlIGlmICgnb25tb3pmdWxsc2NyZWVuY2hhbmdlJyBpbiBkb2N1bWVudCkge1xuICAgICAgICBmdWxsc2NyZWVuY2hhbmdlID0gJ21vemZ1bGxzY3JlZW5jaGFuZ2UnO1xuICAgIH0gZWxzZSBpZiAoJ29ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgZnVsbHNjcmVlbmNoYW5nZSA9ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJztcbiAgICB9IGVsc2UgaWYgKCdvbm1zZnVsbHNjcmVlbmNoYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgZnVsbHNjcmVlbmNoYW5nZSA9ICdNU0Z1bGxzY3JlZW5DaGFuZ2UnO1xuICAgIH1cblxuICAgIGlmIChmdWxsc2NyZWVuY2hhbmdlKSB7XG4gICAgICAgIHZhciBvbkZ1bGxzY3JlZW5DaGFuZ2UgPSBMLmJpbmQodGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlLCB0aGlzKTtcblxuICAgICAgICB0aGlzLndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCBmdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCd1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgZnVsbHNjcmVlbmNoYW5nZSwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbkwuY29udHJvbC5mdWxsc2NyZWVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEwuQ29udHJvbC5GdWxsc2NyZWVuKG9wdGlvbnMpO1xufTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRTyxlQUFTLE9BQU8sTUFBTTtBQUM1QixZQUFJLEdBQUcsR0FBRyxLQUFLO0FBRWYsYUFBSyxJQUFJLEdBQUcsTUFBTSxVQUFVLFFBQVEsSUFBSSxLQUFLLEtBQUs7QUFDakQsZ0JBQU0sVUFBVSxDQUFDO0FBQ2pCLGVBQUssS0FBSyxLQUFLO0FBQ2QsaUJBQUssQ0FBQyxJQUFJLElBQUksQ0FBQztVQUNsQjtRQUNBO0FBQ0MsZUFBTztNQUNSO0FBSU8sVUFBSUEsV0FBUyxPQUFPLFVBQVcsMkJBQVk7QUFDakQsaUJBQVMsSUFBSTtRQUFBO0FBQ2IsZUFBTyxTQUFVLE9BQU87QUFDdkIsWUFBRSxZQUFZO0FBQ2QsaUJBQU8sSUFBSSxFQUFDO1FBQ2Q7TUFDQSxFQUFDO0FBS00sZUFBUyxLQUFLLElBQUksS0FBSztBQUM3QixZQUFJLFFBQVEsTUFBTSxVQUFVO0FBRTVCLFlBQUksR0FBRyxNQUFNO0FBQ1osaUJBQU8sR0FBRyxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssV0FBVyxDQUFDLENBQUM7UUFDbkQ7QUFFQyxZQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQztBQUVsQyxlQUFPLFdBQVk7QUFDbEIsaUJBQU8sR0FBRyxNQUFNLEtBQUssS0FBSyxTQUFTLEtBQUssT0FBTyxNQUFNLEtBQUssU0FBUyxDQUFDLElBQUksU0FBUztRQUNuRjtNQUNBO0FBSU8sVUFBSSxTQUFTO0FBSWIsZUFBUyxNQUFNLEtBQUs7QUFDMUIsWUFBSSxFQUFFLGlCQUFpQixNQUFNO0FBQzVCLGNBQUksYUFBYSxJQUFJLEVBQUU7UUFDekI7QUFDQyxlQUFPLElBQUk7TUFDWjtBQVNPLGVBQVMsU0FBUyxJQUFJLE1BQU0sU0FBUztBQUMzQyxZQUFJLE1BQU0sTUFB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RTtBQUFBLFlBQ3BDLE9BQU87QUFDSCxtQkFBSyxVQUFVLEVBQUU7QUFBQSxZQUNyQjtBQUFBLFVBQ0osQ0FBQztBQUFBLFFBQ0w7QUFBQSxRQUNBO0FBQUEsVUFDSSxNQUFNO0FBQUE7QUFBQSxVQUNOLFlBQVk7QUFBQTtBQUFBLFVBQ1osV0FBVztBQUFBO0FBQUEsUUFDZjtBQUFBLE1BQ0o7QUFDQSxlQUFTLFFBQVEsRUFBRTtBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUNKO0FBQ0EsT0FBTyxjQUFjLElBQUksWUFBWSxtQkFBbUIsQ0FBQzsiLAogICJuYW1lcyI6IFsiY3JlYXRlIiwgInN0ciIsICJVdGlsLnNldE9wdGlvbnMiLCAiVXRpbC5jcmVhdGUiLCAiVXRpbC5leHRlbmQiLCAiaSIsICJVdGlsLmlzQXJyYXkiLCAiVXRpbC5zcGxpdFdvcmRzIiwgIlV0aWwuZmFsc2VGbiIsICJpbmRleCIsICJVdGlsLnN0YW1wIiwgIkxhdExuZyIsICJVdGlsLmZvcm1hdE51bSIsICJ6b29tIiwgInNjYWxlIiwgIlV0aWwud3JhcE51bSIsICJjYW52YXMiLCAic3ZnIiwgIkRvbUV2ZW50LnByZXZlbnREZWZhdWx0IiwgIkRvbUV2ZW50LmdldFByb3BhZ2F0aW9uUGF0aCIsICJzdHlsZSIsICJVdGlsLnRyaW0iLCAiRG9tRXZlbnQub24iLCAiRG9tRXZlbnQub2ZmIiwgInR5cGUiLCAiVXRpbC5pbmRleE9mIiwgIkRvbVV0aWwuZ2V0UG9zaXRpb24iLCAiVXRpbC5yZXF1ZXN0QW5pbUZyYW1lIiwgIkRvbVV0aWwuc2V0UG9zaXRpb24iLCAiVXRpbC5jYW5jZWxBbmltRnJhbWUiLCAiVXRpbC5iaW5kIiwgIkRvbVV0aWwuVFJBTlNJVElPTiIsICJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwgIkRvbVV0aWwuYWRkQ2xhc3MiLCAiRG9tVXRpbC5yZW1vdmUiLCAiRG9tVXRpbC5jcmVhdGUiLCAiRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbiIsICJEb21VdGlsLmdldCIsICJEb21VdGlsLmdldFN0eWxlIiwgInJlbW92ZSIsICJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwgIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCAiRG9tVXRpbC5yZW1vdmVDbGFzcyIsICJEb21VdGlsLlRSQU5TRk9STSIsICJEb21VdGlsLnNldFRyYW5zZm9ybSIsICJDb250cm9sIiwgIm1hcCIsICJjb250cm9sIiwgIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwgIkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsICJEb21VdGlsLmVtcHR5IiwgIkRvbUV2ZW50LnN0b3AiLCAicHJldmVudE91dGxpbmUiLCAiRG9tVXRpbC5oYXNDbGFzcyIsICJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCAiRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiIsICJEb21VdGlsLmdldFNpemVkUGFyZW50Tm9kZSIsICJEb21VdGlsLmdldFNjYWxlIiwgIkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnIiwgIkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiIsICJlZGdlIiwgIkxpbmVVdGlsLl9nZXRCaXRDb2RlIiwgIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwgIkxpbmVVdGlsLmlzRmxhdCIsICJsYXllcnMiLCAiZmVhdHVyZUdyb3VwIiwgInBvaW50IiwgIm1hcmtlciIsICJpY29uIiwgImxhdExuZyIsICJEb21VdGlsLnNldE9wYWNpdHkiLCAiTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50IiwgIkxpbmVVdGlsLnBvbHlsaW5lQ2VudGVyIiwgIkxpbmVVdGlsLmNsaXBTZWdtZW50IiwgIkxpbmVVdGlsLnNpbXBsaWZ5IiwgIkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCAiTGluZVV0aWwuX2ZsYXQiLCAiUG9seWdvbiIsICJQb2x5VXRpbC5wb2x5Z29uQ2VudGVyIiwgIlBvbHlVdGlsLmNsaXBQb2x5Z29uIiwgInBvbHlnb24iLCAiRG9tVXRpbC50b0Zyb250IiwgIkRvbVV0aWwudG9CYWNrIiwgIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsICJwb3B1cCIsICJ0b29sdGlwIiwgImRpdkljb24iLCAiVXRpbC50aHJvdHRsZSIsICJsYXRMbmdCb3VuZHMiLCAiVXRpbC50ZW1wbGF0ZSIsICJVdGlsLmVtcHR5SW1hZ2VVcmwiLCAidGlsZUxheWVyIiwgIkRvbUV2ZW50LmdldFdoZWVsRGVsdGEiLCAiTCIsICJtYXAiLCAicG9seWdvbiJdCn0K
